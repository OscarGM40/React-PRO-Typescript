				SECCION 08 STATE INITIALIZER + FUNCTION CHILD = RENDER PROPS


En esta sección 8 veremos el último patrón que es STATE INITIALIZER + FUNCTION CHILD + RENDER PROPS. Este patrón es el que usa FORMIK.
Formik nos da una manera de trabajar con formularios,nos crea un Objeto con el cual tengo control absoluto y acceso a esos componentes(en este caso un form,pero puede ser otro componente).
De nuevo los consumidores tendrán la opción de cambiar lo que desean,o lo que yo quiera dejarles como dev.
Fijate que el patrón se llama State Initializer,pide un state inicial y una forma de re-establecer el estado a su forma original,algo que ya he visto con Angular y Form Builder.

Lo que están apunto de observar en esta sección es el patrón State Initializer junto al diseño de componentes que utiliza Formik.

El principal objetivo es poder exponer todo lo que el usuario (otro desarrollador) puede utilizar, el patrón principalmente pide que se pueda ofrecer un estado inicial y una forma de re-establecer el estado a su forma original, pero nosotros aquí lo llevaremos a otro nivel exponiendo funciones y nuevas propiedades.

También aprenderemos a enviar una función como children, similar a la implementación de Formik.

					VIDEO 97 CONTINUACION PROYECTO

Refactorizo según indica Fernando.Fijate que Formik usa este patrón usando la property 'initialValues' y 'validate'.
Lo interesante es que puedo fijar un estadoInicial(por ejemplo,cargando desde el localStorage ese initialState o limitando las existencias máximas de un producto)
También podría fijar que un usuario sólo pueda comprar un producto,por ejemplo,si es una entrada para el fútbol(productos de alta demanda).

Puedo ver que Formik usa un HOC,algunas properties ya mencionadas y un child que es una función que retorna HTML(es decir tiene como hijo un JSX.Element | React.ReactElement).
Puedo observar que se tiene mucho control sobre este grupo de HOC+()=>JSX.Element,lo cual hace que este patrón sea muy usado y muy útil.

				VIDEO 98 IMPLEMENTAR LA PROPIEDAD INITIAL-VALUES

IMPORTANTE: la propiedad initialValues es un Objeto,que a su vez necesitará estar en una expresión embebida,asi que usará {{}}.Ejemplo:

<ProductCard key={product.id} product={product} className="bg-dark"
  initialValues={{
  count:4,
  maxCount:10
 }}

Esto marcará un error ya que estamos en Typescript,asi que hay que retocar las props que recibe ese ProductCard:


interface InitialValues {
  count?:number;
  maxCount?:number;

}

export interface ProductCardProps {
  product: Product;
  children?: ReactElement | ReactElement[];
  className?: string;
  style?: CSSProperties;
  onChange?: (args:onChangeArgs) => void;
  value?:number;
  initialValues?:InitialValues;
}

Fijate que todo es opcional,tanto recibir la prop,como las props de ese objeto si es que lo recibo.
Y tengo que mandarlo al que controla el estado,en este caso lo dejamos con la forma en la que el setter del customHook primero lo controlaba asi que:

  const { counter, increaseBy } = useProduct({
    product,
    onChange,
    value,
    initialValues
    });

Ahora puedo decir que si viene un count de,por ejemplo una DB o un localStorage,  se inicie con ese valor:
 const [counter, setCounter] = useState<number>(initialValues?.count || value);

Sin embargo veré que el efecto se mete por medio y no lo inicia en 4 sino en 0,ya que se dispara su lógica y lo cambia al value=0.

				VIDEO 99 MOSTRAR EL VALOR INICIAL DEL COMPONENTE

Fernando va a usar una ref<boolean> pero fijate que un useRef no es necesario pasarlo como dependencia en un useEffect(interesante):
  /* NOTA:un useRef no hace falta mandarlo como dependencia en un efecto */
   useEffect(() => { 
    if( !isMounted.current) { 
      return;}
    setCounter(value);    
  }, [value]); 
  
   useEffect(() => {
    isMounted.current=true;
  }, []);
   
				VIDEO 100 UTILIZAR EL MAX-COUNT COMO LIMITANTE

Solo hay que cambiar un poco el código:
     const newValue = initialValues?.maxCount 
      ? Math.max(Math.min(counter + value, initialValues.maxCount),0) 
      : Math.max(counter+value,0)
    setCounter(newValue);
NOTA:fijate que siempre estamos llamando al setter,aunque React no renderizará de nuevo el componente si el valor es el mismo(al tratar de incrementar estando ya en el tope o de decrementar estando en 0 React no va a re-renderizar el componente,pero si que estamos llamando a la función.
Podriamos ser más precisos y controlar esto.

			VIDEO 101 PASAR UNA FUNCION CHILD AL HOC CON SUS PROPS

El patrón de State Initializer exige que aparte de poder dar al usuario la opción de mandar un state inicial,darle la forma de resetear o reinicializarse a ese valor.Será algo asi.

<ShoppingPage>
  { () => (<h1>Soy un JSX </1>) }
</ShoppingPage>

Fijate que ahora lo que se pasa por children es una funcion que devolverá el componente,y no el componente en si.Esto va a obligar a un par de cosas:

1- *children ya no devolverá un JSX sino un () => JSX,obviamente:
  // children?: ReactElement | ReactElement[]; <- ya no se devuelve directamente
  children: () => JSX.Element; <- si no que se devuelve un f que retorna el JSX

2- *React no puede renderizar funciones,puede renderizar JSX,pero no una funcion que retorne algo(no puede renderizar () => ('123')luego ya no puedo retornar ese children(pero si que puede retornar su ejecución,ojo):
 <div>
 { children } <- dado que children es () => JSX si que puedo ejecutarla para que se infiera ese JSX.IMPORTANTE!

NOTA:fijate que ya casi me dijo él lo que tenia que hacer:
Warning: Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.
    at div

Simplemente es llamar a la funcion.Sin embargo fijate que ahora tengo beneficios por ser una función y no una variable como era:
   <div >
    { children() }

NOTA:dado que es una función yo puedo mandar argumentos.Esto es un beneficio claro.Por ejemplo,podemos mandar un simple string:

  children: (mensaje:string) => JSX.Element;

 <div>
  { children('este es el mensaje')

Y lógicamente lo podré recibir en esa función:

  <div ...
    initialValues={{...}}
  >
  { (mensaje) => (
      <h1> {mensaje} </h1>
   ) }
  </div>

Es decir que yo puedo exponer y mandar todas las props que quiera ahora,y darle todo procesado a los children de este componente <ProductCard>

				VIDEO 102 TAREA - IS MAX COUNT REACED

REalmente no era tan dificil,pero,importante,fijate que useCallback devuelve una función siempre(no puede devolver una variable,siempre va a devolver una función memorizada que además volverá a ejecutarse cuando cambien sus dependencias.
Fijate que lo que hago es llamar a una función,que será cacheada,y sólo en base a ciertas dependencias se ejecuta de nuevo,sino se me devuelve la cacheada:

  const isMaxReached =  useCallback(() => {
    return counter === maxCount;
  }, [counter,maxCount]);

Si no cambia el counter ni el maxCount isMaxReached es una función cacheada,siempre la misma.Perfecto.

NOTA: podria incluso ni siquiera evaluar esa condicion si no viene el maxCount:
  const isMaxReached =  useCallback(() => {
    /* mejor que ni evalue la condicion si no hay un maxCount */
    return !!maxCount && counter === maxCount;
  }, [counter,maxCount]);
La clave está en que !!maxCount de undefined será false.Memoriza que puedes comprobar la existencia de cualquier variable con !!var.

NOTA: fijate que también podia haber usado && para la clase condicional:
 en vez de el ternario
 ${ isMaxReached() ? styles.disabled : null }
${ isMaxReached() && styles.disabled } <- fijate que cuando sea false la va a quitar.

DIFERENCIAS ENTRE USECALLBACK Y USEMEMO
useCallback: devuelve una funcion memorizada
useMemo: devuelve un valor memorizado
Ambas esperan una funcion y un arreglo de dependencias.La diferencia es que useCallback devuelve su funcion callback cuando las dependencias cambian mientras que useMemo llamará a la función y devolverá su valor
Y fijate que ambas cambiarán su retorno solo si las dependencias cambian.mientras no cambien devuelven lo memorizado.

		VIDEO 103 EXPONER FUNCIONES Y PROPIEDADES FUERA DEL COMPONENTE

Vamos a cambiar ese string que recibimos.Creamos esta interfaz y se la pasamos a la ejecución del método children:

export interface ProductCardHandlers {
  count: number;
  isMaxCountReached:boolean;
  maxCount?: number;
  product: Product;
  
  increaseBy: ( value: number ) => void;
  reset: () => void;
}

 children: (args: ProductCardHandlers) => JSX.Element;

Y ahora los mando simplemente,igual que mandaba el string anteriormente:
   { children({
     count: counter,
     increaseBy,
     isMaxCountReached,
     maxCount: initialValues?.maxCount,
     product,
     reset,
   }) }

Ahora ya tengo acceso a un montón de cosas(realmente tengo acceso a lo que quiera mandar).Por ejemplo podemos hacer un reset:
    {
      ({reset}) => (
      <>
       <ProductImage className="custom-image" />
       <ProductTitle className="text-white text-custom" />
       <ProductButtons className="custom-buttons" />
       <button onClick={ reset }>Reset</button>
      </>
      )
    }
Puedo apreciar la potencia de este patrón.

		VIDEO 104 TRABAJAR CON TODA LA INFORMACIÓN EXPUESTA COMO ARGUMENTO

Una vez llegados a este punto podemos hacer lo que queramos con el código:
     <button onClick={ args.reset }>Reset</button>
     <button onClick={() => args.increaseBy(-2)}>-2</button>

     { !args.isMaxCountReached  && <button
         onClick={() => args.increaseBy(2) } >+2</button>}

     <span>{args.count} - {args.maxCount }</span>

Recuerda que tengo esta sección siempre disponible para revisualizarla si necesito implementar este patrón de State Initializer.
Guardo el commit y creo una rama state-initializer por ejemplo.

		SECCION 09 NPM DEPLOY - DESPLEGAR PAQUETES DE COMPONENTES

Esta sección tiene por objetivo desplegar todo lo visto hasta ahora a NPM.Vamos a hacer varias secciones de despliegue,con varias herramientas.
En principio usaremos TxDx,ya que aunque es muy verbosa dejará las bases de lo necesario para despliegues bien cimentadas.

Aquí realizaremos el primer despliegue a NPM de nuestro paquete.

Eventualmente lo haremos utilizando Storybook, pero por ahora lo haremos de la forma como tenemos nuestro componente y una forma directa de hacerlo.

Es importante también realizarlo con TypeScript y exponer los archivos de definición para que otros desarrolladores que también usen TypeScript, también tengan el auto-completado y manejo de errores.

			VIDEO 108 PREPARACIÓN DE NUESTRO JUEGO DE COMPONENTES

La idea es subir a NPM e importarlo como si fuera cualquier otro paquete.Vamos a crear otra rama,llamada pre-npm y quitar todas las clases css custom(seguir indicaciones de Fernando)

					VIDEO 109 CREAR PROYECTO DE TSDX

Hay que crear un nuevo proyecto con todo lo que quiero subir a npm.La idea es crear algo parecido a una app de Rect con todo lo que pide NPM para subir una aplicación con ellos.

NOTA: puedo buscar cualquier proyecto npm y veré un enlace a su repo de GitHub | Gitlab.Alli puedo comprobar los requerimientos,como por ejemplo la carpeta dist(implementar un ejemplo,aunque esto es opcional).La carpeta lib con todo el código,la carpeta test con las pruebas...
También pide un archivo de licencias para saber que licencia va a utilizar nuestro proyecto.
El package.json es muy importante,ya que especifica las dependencias de este paquete que subo.Además,ciertas propiedades son muy importantes:
name <- debe coincidir
version <- muy importante ya que tengo que incrementarla
description <- también importante
main <- el punto de entrada debe estar correcto
types <- indica el file con los archivos de definición,también es clave
scripts
repository <- es el que se verá en la web
keywords <- aparecen al final en la web
homepage <- puedo indicar un enlace que se verá también
devDependencies <- no se instalarán,son las que necesitó el paquete para hacerse
dependencies <- estas si se instalarán automáticamente al instalarse mi módulo

Es bastante tedioso crear todo esto desde 0,puedo utilizar tsdx para que cree algo parecido a un paquete ya listo para subirse a npm(tsdx es como create-react-app
>npx tsdx create <nombre_paquete>

Si es la primera vez lo instalará.Eligo la opción react(basic es un simple proyecto de ts sin un framework y ya veremos más adelante react-with-storybook).Podria cambiarme a este proyecto y ejecutarlo,pero no veré nada.

Desde ya puedo ver que ha creado esos folder que solicita npm (dist,example,test y src) y los files LICENSE y package.json obligatorios.

				VIDEO 110 ESTRUCTURA DE UN PROYECTO TSDX

NOTA: tsdx es una cli para typescript,para desplegar paquetes en TS(de ahi su nombre),de forma rápida.
IMPORTANTE: el README es lo que se ve en la web de npm,en el paquete,todo lo que se vea aqui o quiera que se vea lo tengo que escribir en MD.Asi que lo edito con lo que quiera.
En cuanto al package.json está casi todo correcto,quizás la version seria mejor usar la 0.0.1:

  "version": "0.0.1",
  "license": "MIT",
  "main": "dist/index.js",
  "typings": "dist/index.d.ts",

  "engines": {
    "node": ">=10"  <-podria incluso subirlo
  },

Esto si es importante,las peerDependencies,a diferencia de las normales o las de desarrollo son dependencias que la persona tiene que satisfacer:
  "peerDependencies": {
    "react": ">=16"
  },
En este caso la persona que use este paquete necesita usar React 16,no le instalaré nada(eso iria en dependencies) y las devDependencies son para realizar este proyecto,no tienen nada que ver con el paquete.

IMPORTANTE: en el file LICENSE veré que por defecto está en MIT.Esto es correcto,es la licencia estandar en los proyectos de software libre(el que lo instale puede cambiar el código a su antojo,yo no me hago responsable de nada,etc...)
El .gitignore viene correctamente también.
En test puedo ejecutar pruebas.
En src/index.tsx es donde voy a poner el código
En example/* se suele poner un ejemplo,siempre es útil,sobre todo cuando es un paquete complejo
En dist/** es lo que terminaré subiendo y la gente termina consumiendo.Hay varios archivos javascript segun environment.
También está la .github/workflows con dos yaml por si quiero usar Ci/CD

				PASO DOS OPTIMIZAR EL SRC/INDEX.TSX

Sigo las ordenes de Fernando.Fijate que al final en el index.tsx tengo que exportar todo lo que el usuario necesite importar de mi paquete,y justamente es lo que tengo en components/index.ts:
* En el src/index simplemente exporto lo del components/index
export * from './components';

NOTA: cuando compile con npm start veré un error al tratar de importar un archivo css.Esto es porque estoy intentando cargar un archivo css como si fuera javascript,lo cual obviamente es un error,si.
Hay que configurar el proyecto para permitir importar los estilos como módulos(diría que es porque usamos ModuleCSS y no css normales)

			VIDEO 112 PASO 3 CONFIGURAR EL USO DE MODULOS

Si tu código que estás creando tiene imágenes importadas de esta forma y/o CSS
modularizado de esta forma(si uso CSS modules):

import noImage from ‘../assets/no-image.jpg';
import styles from ‘../styles/styles.module.css';

Necesitaremos crear un archivo de configuración de TSDX “tsdx.config.js” en la raíz que nos ayudará en el proceso de construcción de nuestro paquete

Ovbiamente con create-react-app puedo importar imagenes o estilos de esta forma pero en tsdx esto no es válido.La solución es crear un archivo de configuración para tsdx en la raiz (tsdx.config.js).

Copio el siguiente ćodigo del pdf de Fernando,con el que estamos añadiendo dos plugins nuevos:

const postcss = require('rollup-plugin-postcss');
const images = require('@rollup/plugin-image');

module.exports = {
 rollup(config, options) {

   config.plugins = [
     postcss({ modules: true }),
     images({ incude: ['**/*.png', '**/*.jpg'] }),
      ...config.plugins,
   ];
   return config;
 },
};

IMPORTANTE:  aun falta los type definition,debo crear otro file en src/typings.d.ts con ese nombre.Fernando deja un gist con el código para este file:

GIST: https://gist.github.com/Klerith/be084330d6522bb4576a42b068e9b842

Código:
declare module '*.css' {
  const content: { [className: string]: string };
  export default content;
}

declare module "*.jpg" {
  const value: any;
  export default value;
}

Obviamente me pide realizar las instalaciones respectivas para esas dependencies:

yarn add -D rollup-plugin-postcss
yarn add -D @rollup/plugin-image

Ojo,que los paquetes están siendo importados mediante require.

Bien,compilo de nuevo y vemos otro error:
'React' refers to a UMD global, but the current file is a module. Consider adding an import instead.ts(hay que importar react en cada uno de los lugares que use JSX,a pesar de estar en React 17).
En resumen tengo que dejar todo compilando satisfactoriamente:
✔ Compiled successfully <- asinto
Una vez compilando todo OK lo siguiente sería hacer el build(npm build)

					PASO 4 REALIZAR EL BUILD

Siempre asegurandonos que compila satisfactoriamente,ejecutamos el comando build(el cual ejecutará 'tsdx build'.Esto creará el directorio 'dist'.

También creará un montón de .d.ts(data definition types).

NOTA: es buena idea definir los PropTypes por si el usuario fuera a usar Javascript cual prehistoric:
En TS hay que instalarlas:

npm install --save prop-types
npm install --save-dev @types/prop-types

EN un componente llamado Article...
Article.propTypes = {
  title: PropTypes.string.isRequired,
  price: PropTypes.number.isRequired,
};

De momento no lo haremos porque con TS es suficiente.

				VIDEO 114 PASO 6 - GITHUB REPO -

Es conveniente que el proyecto sea un repositorio,puede que eventualmente lo transfiera  o invite a colaboradores, o bien aceptar mejoras de otros desarrolladores.
Para agregar un repo:
"repository":{
  "url":"https://github.com/<tu_repositorio>",
  "type":"git"	

Y de tener un sitio web se suele agregar la prop 'homepage' en el package.json:
"homepage":"https://midominio.com"

Adicionalmente,si quiero que el paquete sea fácilmente visible por la comunidad e indexado por los bots de Google y otros,debo añadir la llave 'keywords' con un arreglo de palabras clave:
"keywords":["product","card"] 

NOTA: las propiedades pueden ir en cualquier linea del package.json.Y todo esto se verá al entrar al npm Registry.
Fijate que todo esto es opcional,y ya podriamos publicarlo,si,pero en la realidad siempre se debería pasar un repo,una web de enlace y keywords clave,asi que es mejor verlo como obligatorio.

						VIDEO 115 PRUEBAS AUTOMATICAS

Tener pruebas automáticas es importantisimo.Especialmente en un paquete que despliego y publico.

Las pruebas automáticas,además de asegurar que la funcionalidad está siendo respetada, me preveen contra breaking changes,asegurando que la funcionalidad anterior también funciona tras una actualización(lo cual obviamente debe hacer).

Haremos una pequeña prueba básica.Fijate que me pide los type definitions pasar:
npm i --save-dev @types/jest
npm i --save-dev @types/mocha

NOTA: no funciona esto(normal,si no tiene ni jest instalado,peazo asinto),seguiré por el PDF de Fernando mejor:

Preferencia personal: Jest
1- Instalar las dependencias en modo dev necesarias:
>npm add --dev jest babel-jest @babel/preset-env @babel/preset-react react-test-renderer identity-obj-proxy

2- Instalar la contraparte de TypeScript(fijate que con tsdx me falta todo):
yarn add @types/react @types/react-dom @types/react-test-renderer @types/jest

3-Vamos a tener el mismo problema con las imagenes y los CssModules que hemos usado.En el package.json ignoraremos las imágenes y css cargados como módulos de JavaScript que darán error.
 Añadir la siguiente configuración en el package.json:

"jest":{
   "moduleNameMapper": {
      "\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|
m4a|aac|oga)$": "identity-obj-proxy",
       "\\.(css|less|scss|sass)$": "identity-obj-proxy"
 } }

3- Preferencia personal, creamos otro script con --watch para que se quede en modo observador y no finalize la suite de pruebas.

Crear el siguiente script en el package.json:
"test:watch": "tsdx test --watch",

Una vez instalado todo faltará hacer alguna configuración.

					VIDEO 116 PRUEBAS EN PRODUCT TITLE

NOTA: al final solucioné el error con import '@types/jest';
'React' refers to a UMD global, but the current file is a module <- import React from 'react';

Hacemos un par de pruebas con esta libreria react-test-renderer en vez de enzyme.Habrá que usar su método renderer.create en vez de shallow,pues no estamos con enzyme.

  test('debe de mostrar el componente con el nombre del producto', () => {
    const wrapper = renderer.create(
    <ProductCard product={product1} >
      { () => (
        <ProductTitle />
      
        )
      }
    </ProductCard>
      );

    expect(wrapper.toJSON()).toMatchSnapshot();
  });

Comprobamos en el folder de las snapshots visualmente que todo esté correcto.

				VIDEO 117 PRUEBAS EN PRODUCT IMAGE





