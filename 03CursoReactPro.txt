				SECCION 08 STATE INITIALIZER + FUNCTION CHILD = RENDER PROPS


En esta sección 8 veremos el último patrón que es STATE INITIALIZER + FUNCTION CHILD + RENDER PROPS. Este patrón es el que usa FORMIK.
Formik nos da una manera de trabajar con formularios,nos crea un Objeto con el cual tengo control absoluto y acceso a esos componentes(en este caso un form,pero puede ser otro componente).
De nuevo los consumidores tendrán la opción de cambiar lo que desean,o lo que yo quiera dejarles como dev.
Fijate que el patrón se llama State Initializer,pide un state inicial y una forma de re-establecer el estado a su forma original,algo que ya he visto con Angular y Form Builder.

Lo que están apunto de observar en esta sección es el patrón State Initializer junto al diseño de componentes que utiliza Formik.

El principal objetivo es poder exponer todo lo que el usuario (otro desarrollador) puede utilizar, el patrón principalmente pide que se pueda ofrecer un estado inicial y una forma de re-establecer el estado a su forma original, pero nosotros aquí lo llevaremos a otro nivel exponiendo funciones y nuevas propiedades.

También aprenderemos a enviar una función como children, similar a la implementación de Formik.

					VIDEO 97 CONTINUACION PROYECTO

Refactorizo según indica Fernando.Fijate que Formik usa este patrón usando la property 'initialValues' y 'validate'.
Lo interesante es que puedo fijar un estadoInicial(por ejemplo,cargando desde el localStorage ese initialState o limitando las existencias máximas de un producto)
También podría fijar que un usuario sólo pueda comprar un producto,por ejemplo,si es una entrada para el fútbol(productos de alta demanda).

Puedo ver que Formik usa un HOC,algunas properties ya mencionadas y un child que es una función que retorna HTML(es decir tiene como hijo un JSX.Element | React.ReactElement).
Puedo observar que se tiene mucho control sobre este grupo de HOC+()=>JSX.Element,lo cual hace que este patrón sea muy usado y muy útil.

				VIDEO 98 IMPLEMENTAR LA PROPIEDAD INITIAL-VALUES

IMPORTANTE: la propiedad initialValues es un Objeto,que a su vez necesitará estar en una expresión embebida,asi que usará {{}}.Ejemplo:

<ProductCard key={product.id} product={product} className="bg-dark"
  initialValues={{
  count:4,
  maxCount:10
 }}

Esto marcará un error ya que estamos en Typescript,asi que hay que retocar las props que recibe ese ProductCard:


interface InitialValues {
  count?:number;
  maxCount?:number;

}

export interface ProductCardProps {
  product: Product;
  children?: ReactElement | ReactElement[];
  className?: string;
  style?: CSSProperties;
  onChange?: (args:onChangeArgs) => void;
  value?:number;
  initialValues?:InitialValues;
}

Fijate que todo es opcional,tanto recibir la prop,como las props de ese objeto si es que lo recibo.
Y tengo que mandarlo al que controla el estado,en este caso lo dejamos con la forma en la que el setter del customHook primero lo controlaba asi que:

  const { counter, increaseBy } = useProduct({
    product,
    onChange,
    value,
    initialValues
    });

Ahora puedo decir que si viene un count de,por ejemplo una DB o un localStorage,  se inicie con ese valor:
 const [counter, setCounter] = useState<number>(initialValues?.count || value);

Sin embargo veré que el efecto se mete por medio y no lo inicia en 4 sino en 0,ya que se dispara su lógica y lo cambia al value=0.

				VIDEO 99 MOSTRAR EL VALOR INICIAL DEL COMPONENTE

Fernando va a usar una ref<boolean> pero fijate que un useRef no es necesario pasarlo como dependencia en un useEffect(interesante):
  /* NOTA:un useRef no hace falta mandarlo como dependencia en un efecto */
   useEffect(() => { 
    if( !isMounted.current) { 
      return;}
    setCounter(value);    
  }, [value]); 
  
   useEffect(() => {
    isMounted.current=true;
  }, []);
   
				VIDEO 100 UTILIZAR EL MAX-COUNT COMO LIMITANTE

Solo hay que cambiar un poco el código:
     const newValue = initialValues?.maxCount 
      ? Math.max(Math.min(counter + value, initialValues.maxCount),0) 
      : Math.max(counter+value,0)
    setCounter(newValue);
NOTA:fijate que siempre estamos llamando al setter,aunque React no renderizará de nuevo el componente si el valor es el mismo(al tratar de incrementar estando ya en el tope o de decrementar estando en 0 React no va a re-renderizar el componente,pero si que estamos llamando a la función.
Podriamos ser más precisos y controlar esto.

			VIDEO 101 PASAR UNA FUNCION CHILD AL HOC CON SUS PROPS

El patrón de State Initializer exige que aparte de poder dar al usuario la opción de mandar un state inicial,darle la forma de resetear o reinicializarse a ese valor.Será algo asi.

<ShoppingPage>
  { () => (<h1>Soy un JSX </1>) }
</ShoppingPage>

Fijate que ahora lo que se pasa por children es una funcion que devolverá el componente,y no el componente en si.Esto va a obligar a un par de cosas:

1- *children ya no devolverá un JSX sino un () => JSX,obviamente:
  // children?: ReactElement | ReactElement[]; <- ya no se devuelve directamente
  children: () => JSX.Element; <- si no que se devuelve un f que retorna el JSX

2- *React no puede renderizar funciones,puede renderizar JSX,pero no una funcion que retorne algo(no puede renderizar () => ('123')luego ya no puedo retornar ese children(pero si que puede retornar su ejecución,ojo):
 <div>
 { children } <- dado que children es () => JSX si que puedo ejecutarla para que se infiera ese JSX.IMPORTANTE!

NOTA:fijate que ya casi me dijo él lo que tenia que hacer:
Warning: Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.
    at div

Simplemente es llamar a la funcion.Sin embargo fijate que ahora tengo beneficios por ser una función y no una variable como era:
   <div >
    { children() }

NOTA:dado que es una función yo puedo mandar argumentos.Esto es un beneficio claro.Por ejemplo,podemos mandar un simple string:

  children: (mensaje:string) => JSX.Element;

 <div>
  { children('este es el mensaje')

Y lógicamente lo podré recibir en esa función:

  <div ...
    initialValues={{...}}
  >
  { (mensaje) => (
      <h1> {mensaje} </h1>
   ) }
  </div>

Es decir que yo puedo exponer y mandar todas las props que quiera ahora,y darle todo procesado a los children de este componente <ProductCard>

				VIDEO 102 TAREA - IS MAX COUNT REACED

REalmente no era tan dificil,pero,importante,fijate que useCallback devuelve una función siempre(no puede devolver una variable,siempre va a devolver una función memorizada que además volverá a ejecutarse cuando cambien sus dependencias.
Fijate que lo que hago es llamar a una función,que será cacheada,y sólo en base a ciertas dependencias se ejecuta de nuevo,sino se me devuelve la cacheada:

  const isMaxReached =  useCallback(() => {
    return counter === maxCount;
  }, [counter,maxCount]);

Si no cambia el counter ni el maxCount isMaxReached es una función cacheada,siempre la misma.Perfecto.

NOTA: podria incluso ni siquiera evaluar esa condicion si no viene el maxCount:
  const isMaxReached =  useCallback(() => {
    /* mejor que ni evalue la condicion si no hay un maxCount */
    return !!maxCount && counter === maxCount;
  }, [counter,maxCount]);
La clave está en que !!maxCount de undefined será false.Memoriza que puedes comprobar la existencia de cualquier variable con !!var.

NOTA: fijate que también podia haber usado && para la clase condicional:
 en vez de el ternario
 ${ isMaxReached() ? styles.disabled : null }
${ isMaxReached() && styles.disabled } <- fijate que cuando sea false la va a quitar.

DIFERENCIAS ENTRE USECALLBACK Y USEMEMO
useCallback: devuelve una funcion memorizada
useMemo: devuelve un valor memorizado
Ambas esperan una funcion y un arreglo de dependencias.La diferencia es que useCallback devuelve su funcion callback cuando las dependencias cambian mientras que useMemo llamará a la función y devolverá su valor
Y fijate que ambas cambiarán su retorno solo si las dependencias cambian.mientras no cambien devuelven lo memorizado.

		VIDEO 103 EXPONER FUNCIONES Y PROPIEDADES FUERA DEL COMPONENTE

Vamos a cambiar ese string que recibimos.Creamos esta interfaz y se la pasamos a la ejecución del método children:

export interface ProductCardHandlers {
  count: number;
  isMaxCountReached:boolean;
  maxCount?: number;
  product: Product;
  
  increaseBy: ( value: number ) => void;
  reset: () => void;
}

 children: (args: ProductCardHandlers) => JSX.Element;

Y ahora los mando simplemente,igual que mandaba el string anteriormente:
   { children({
     count: counter,
     increaseBy,
     isMaxCountReached,
     maxCount: initialValues?.maxCount,
     product,
     reset,
   }) }

Ahora ya tengo acceso a un montón de cosas(realmente tengo acceso a lo que quiera mandar).Por ejemplo podemos hacer un reset:
    {
      ({reset}) => (
      <>
       <ProductImage className="custom-image" />
       <ProductTitle className="text-white text-custom" />
       <ProductButtons className="custom-buttons" />
       <button onClick={ reset }>Reset</button>
      </>
      )
    }
Puedo apreciar la potencia de este patrón.

		VIDEO 104 TRABAJAR CON TODA LA INFORMACIÓN EXPUESTA COMO ARGUMENTO

Una vez llegados a este punto podemos hacer lo que queramos con el código:
     <button onClick={ args.reset }>Reset</button>
     <button onClick={() => args.increaseBy(-2)}>-2</button>

     { !args.isMaxCountReached  && <button
         onClick={() => args.increaseBy(2) } >+2</button>}

     <span>{args.count} - {args.maxCount }</span>

Recuerda que tengo esta sección siempre disponible para revisualizarla si necesito implementar este patrón de State Initializer.
Guardo el commit y creo una rama state-initializer por ejemplo.

		SECCION 09 NPM DEPLOY - DESPLEGAR PAQUETES DE COMPONENTES

Esta sección tiene por objetivo desplegar todo lo visto hasta ahora a NPM.Vamos a hacer varias secciones de despliegue,con varias herramientas.
En principio usaremos TxDx,ya que aunque es muy verbosa dejará las bases de lo necesario para despliegues bien cimentadas.

Aquí realizaremos el primer despliegue a NPM de nuestro paquete.

Eventualmente lo haremos utilizando Storybook, pero por ahora lo haremos de la forma como tenemos nuestro componente y una forma directa de hacerlo.

Es importante también realizarlo con TypeScript y exponer los archivos de definición para que otros desarrolladores que también usen TypeScript, también tengan el auto-completado y manejo de errores.

			VIDEO 108 PREPARACIÓN DE NUESTRO JUEGO DE COMPONENTES

La idea es subir a NPM e importarlo como si fuera cualquier otro paquete.Vamos a crear otra rama,llamada pre-npm y quitar todas las clases css custom(seguir indicaciones de Fernando)

					VIDEO 109 CREAR PROYECTO DE TSDX

Hay que crear un nuevo proyecto con todo lo que quiero subir a npm.La idea es crear algo parecido a una app de Rect con todo lo que pide NPM para subir una aplicación con ellos.

NOTA: puedo buscar cualquier proyecto npm y veré un enlace a su repo de GitHub | Gitlab.Alli puedo comprobar los requerimientos,como por ejemplo la carpeta dist(implementar un ejemplo,aunque esto es opcional).La carpeta lib con todo el código,la carpeta test con las pruebas...
También pide un archivo de licencias para saber que licencia va a utilizar nuestro proyecto.
El package.json es muy importante,ya que especifica las dependencias de este paquete que subo.Además,ciertas propiedades son muy importantes:
name <- debe coincidir
version <- muy importante ya que tengo que incrementarla
description <- también importante
main <- el punto de entrada debe estar correcto
types <- indica el file con los archivos de definición,también es clave
scripts
repository <- es el que se verá en la web
keywords <- aparecen al final en la web
homepage <- puedo indicar un enlace que se verá también
devDependencies <- no se instalarán,son las que necesitó el paquete para hacerse
dependencies <- estas si se instalarán automáticamente al instalarse mi módulo

Es bastante tedioso crear todo esto desde 0,puedo utilizar tsdx para que cree algo parecido a un paquete ya listo para subirse a npm(tsdx es como create-react-app
>npx tsdx create <nombre_paquete>

Si es la primera vez lo instalará.Eligo la opción react(basic es un simple proyecto de ts sin un framework y ya veremos más adelante react-with-storybook).Podria cambiarme a este proyecto y ejecutarlo,pero no veré nada.

Desde ya puedo ver que ha creado esos folder que solicita npm (dist,example,test y src) y los files LICENSE y package.json obligatorios.

				VIDEO 110 ESTRUCTURA DE UN PROYECTO TSDX

NOTA: tsdx es una cli para typescript,para desplegar paquetes en TS(de ahi su nombre),de forma rápida.
IMPORTANTE: el README es lo que se ve en la web de npm,en el paquete,todo lo que se vea aqui o quiera que se vea lo tengo que escribir en MD.Asi que lo edito con lo que quiera.
En cuanto al package.json está casi todo correcto,quizás la version seria mejor usar la 0.0.1:

  "version": "0.0.1",
  "license": "MIT",
  "main": "dist/index.js",
  "typings": "dist/index.d.ts",

  "engines": {
    "node": ">=10"  <-podria incluso subirlo
  },

Esto si es importante,las peerDependencies,a diferencia de las normales o las de desarrollo son dependencias que la persona tiene que satisfacer:
  "peerDependencies": {
    "react": ">=16"
  },
En este caso la persona que use este paquete necesita usar React 16,no le instalaré nada(eso iria en dependencies) y las devDependencies son para realizar este proyecto,no tienen nada que ver con el paquete.

IMPORTANTE: en el file LICENSE veré que por defecto está en MIT.Esto es correcto,es la licencia estandar en los proyectos de software libre(el que lo instale puede cambiar el código a su antojo,yo no me hago responsable de nada,etc...)
El .gitignore viene correctamente también.
En test puedo ejecutar pruebas.
En src/index.tsx es donde voy a poner el código
En example/* se suele poner un ejemplo,siempre es útil,sobre todo cuando es un paquete complejo
En dist/** es lo que terminaré subiendo y la gente termina consumiendo.Hay varios archivos javascript segun environment.
También está la .github/workflows con dos yaml por si quiero usar Ci/CD

				PASO DOS OPTIMIZAR EL SRC/INDEX.TSX

Sigo las ordenes de Fernando.Fijate que al final en el index.tsx tengo que exportar todo lo que el usuario necesite importar de mi paquete,y justamente es lo que tengo en components/index.ts:
* En el src/index simplemente exporto lo del components/index
export * from './components';

NOTA: cuando compile con npm start veré un error al tratar de importar un archivo css.Esto es porque estoy intentando cargar un archivo css como si fuera javascript,lo cual obviamente es un error,si.
Hay que configurar el proyecto para permitir importar los estilos como módulos(diría que es porque usamos ModuleCSS y no css normales)

			VIDEO 112 PASO 3 CONFIGURAR EL USO DE MODULOS

Si tu código que estás creando tiene imágenes importadas de esta forma y/o CSS
modularizado de esta forma(si uso CSS modules):

import noImage from ‘../assets/no-image.jpg';
import styles from ‘../styles/styles.module.css';

Necesitaremos crear un archivo de configuración de TSDX “tsdx.config.js” en la raíz que nos ayudará en el proceso de construcción de nuestro paquete

Ovbiamente con create-react-app puedo importar imagenes o estilos de esta forma pero en tsdx esto no es válido.La solución es crear un archivo de configuración para tsdx en la raiz (tsdx.config.js).

Copio el siguiente ćodigo del pdf de Fernando,con el que estamos añadiendo dos plugins nuevos:

const postcss = require('rollup-plugin-postcss');
const images = require('@rollup/plugin-image');

module.exports = {
 rollup(config, options) {

   config.plugins = [
     postcss({ modules: true }),
     images({ incude: ['**/*.png', '**/*.jpg'] }),
      ...config.plugins,
   ];
   return config;
 },
};

IMPORTANTE:  aun falta los type definition,debo crear otro file en src/typings.d.ts con ese nombre.Fernando deja un gist con el código para este file:

GIST: https://gist.github.com/Klerith/be084330d6522bb4576a42b068e9b842

Código:
declare module '*.css' {
  const content: { [className: string]: string };
  export default content;
}

declare module "*.jpg" {
  const value: any;
  export default value;
}

Obviamente me pide realizar las instalaciones respectivas para esas dependencies:

yarn add -D rollup-plugin-postcss
yarn add -D @rollup/plugin-image

Ojo,que los paquetes están siendo importados mediante require.

Bien,compilo de nuevo y vemos otro error:
'React' refers to a UMD global, but the current file is a module. Consider adding an import instead.ts(hay que importar react en cada uno de los lugares que use JSX,a pesar de estar en React 17).
En resumen tengo que dejar todo compilando satisfactoriamente:
✔ Compiled successfully <- asinto
Una vez compilando todo OK lo siguiente sería hacer el build(npm build)

					PASO 4 REALIZAR EL BUILD

Siempre asegurandonos que compila satisfactoriamente,ejecutamos el comando build(el cual ejecutará 'tsdx build'.Esto creará el directorio 'dist'.

También creará un montón de .d.ts(data definition types).

NOTA: es buena idea definir los PropTypes por si el usuario fuera a usar Javascript cual prehistoric:
En TS hay que instalarlas:

npm install --save prop-types
npm install --save-dev @types/prop-types

EN un componente llamado Article...
Article.propTypes = {
  title: PropTypes.string.isRequired,
  price: PropTypes.number.isRequired,
};

De momento no lo haremos porque con TS es suficiente.

				VIDEO 114 PASO 6 - GITHUB REPO -

Es conveniente que el proyecto sea un repositorio,puede que eventualmente lo transfiera  o invite a colaboradores, o bien aceptar mejoras de otros desarrolladores.
Para agregar un repo:
"repository":{
  "url":"https://github.com/<tu_repositorio>",
  "type":"git"	

Y de tener un sitio web se suele agregar la prop 'homepage' en el package.json:
"homepage":"https://midominio.com"

Adicionalmente,si quiero que el paquete sea fácilmente visible por la comunidad e indexado por los bots de Google y otros,debo añadir la llave 'keywords' con un arreglo de palabras clave:
"keywords":["product","card"] 

NOTA: las propiedades pueden ir en cualquier linea del package.json.Y todo esto se verá al entrar al npm Registry.
Fijate que todo esto es opcional,y ya podriamos publicarlo,si,pero en la realidad siempre se debería pasar un repo,una web de enlace y keywords clave,asi que es mejor verlo como obligatorio.

						VIDEO 115 PRUEBAS AUTOMATICAS

Tener pruebas automáticas es importantisimo.Especialmente en un paquete que despliego y publico.

Las pruebas automáticas,además de asegurar que la funcionalidad está siendo respetada, me preveen contra breaking changes,asegurando que la funcionalidad anterior también funciona tras una actualización(lo cual obviamente debe hacer).

Haremos una pequeña prueba básica.Fijate que me pide los type definitions pasar:
npm i --save-dev @types/jest
npm i --save-dev @types/mocha

NOTA: no funciona esto(normal,si no tiene ni jest instalado,peazo asinto),seguiré por el PDF de Fernando mejor:

Preferencia personal: Jest
1- Instalar las dependencias en modo dev necesarias:
>npm add --dev jest babel-jest @babel/preset-env @babel/preset-react react-test-renderer identity-obj-proxy

2- Instalar la contraparte de TypeScript(fijate que con tsdx me falta todo):
yarn add @types/react @types/react-dom @types/react-test-renderer @types/jest

3-Vamos a tener el mismo problema con las imagenes y los CssModules que hemos usado.En el package.json ignoraremos las imágenes y css cargados como módulos de JavaScript que darán error.
 Añadir la siguiente configuración en el package.json:

"jest":{
   "moduleNameMapper": {
      "\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|
m4a|aac|oga)$": "identity-obj-proxy",
       "\\.(css|less|scss|sass)$": "identity-obj-proxy"
 } }

3- Preferencia personal, creamos otro script con --watch para que se quede en modo observador y no finalize la suite de pruebas.

Crear el siguiente script en el package.json:
"test:watch": "tsdx test --watch",

Una vez instalado todo faltará hacer alguna configuración.

					VIDEO 116 PRUEBAS EN PRODUCT TITLE

NOTA: al final solucioné el error con import '@types/jest';
'React' refers to a UMD global, but the current file is a module <- import React from 'react';

Hacemos un par de pruebas con esta libreria react-test-renderer en vez de enzyme.Habrá que usar su método renderer.create en vez de shallow,pues no estamos con enzyme.

  test('debe de mostrar el componente con el nombre del producto', () => {
    const wrapper = renderer.create(
    <ProductCard product={product1} >
      { () => (
        <ProductTitle />
      
        )
      }
    </ProductCard>
      );

    expect(wrapper.toJSON()).toMatchSnapshot();
  });

Comprobamos en el folder de las snapshots visualmente que todo esté correcto.

				VIDEO 117 PRUEBAS EN PRODUCT IMAGE

Simplemente es hacer lo mismo que en el ProductTitle,comprobar mediante la snapshot que llega una propiedad custom(una imagen cualquiera) y que si se le pasa un producto la coge automáticamente.

				VIDEO 118 PRUEBAS EN PRODUCT CARD

Empezamos creando una snapshot y comprobando que llegan los children y el product,propiedades que puedo ver que son obligatorias:

  it('debe de mostrar el componente correctamente', () => {
    const wrapper = renderer.create(
    <ProductCard product={product2} >
      {() => <h1>Product card</h1>}
      </ProductCard>);
    
    expect(wrapper.toJSON()).toMatchSnapshot();
  });

Fijate que puedo mandar  cualquier cosa como children,pues estoy en pruebas.Fijate que Fernando tiene razón en que estas pruebas son rápidas y bastante útiles,crear una snapshot es una prueba fundamental.

Bien,como no estamos con enzyme vamos a tener que buscarnos la vida parar simular un click y comprobar que incrementa el contador.Lo primero es sacar los métodos y propiedadess necesarios de los children:

   test('debe de incrementar el contador', () => {
    const wrapper = renderer.create(
      <ProductCard product={product2}>
        {
          ({count,increaseBy}) => 
          <>
            <h1>Product card</h1>
            <h2>{count}</h2>
            <button onClick={increaseBy}>+</button>
          </>
        }
      </ProductCard>
    );

Recuerda que puedo usar el html que quiera asi que creamos un boton que llame al increaseBy y un h2 con el count por ejemplo.Fijate como accedemos a ese html:

    let tree = wrapper.toJSON();
	console.log(tree)

      {
        type: 'div',
        props: { className: 'productCard undefined', style: undefined },
        children: [
          { type: 'h1', props: {}, children: [Array] },
          { type: 'h2', props: {}, children: [Array] },
          { type: 'button', props: [Object], children: [Array] }
        ]
      }
Luego puedo acceder a tree.children[2] y simular el click

  (tree as any).children[2].props.onClick();
  tree = wrapper.toJSON();
  expect((tree as any).children[1].children[0]).toBe('1');

NOTA:fijate que da error porque el llamado al increaseBy cambiará el state y debo meter todo en un act.Con esta nueva libreria lo tengo que desestructurar de la propiedad core 'renderer'

/* renderer me proporciona el método act,importante */
const { act } = renderer;

act(() => {
  (tree as any).children[2].props.onClick();
});

IMPORTANTE: este error es porque esa sentencia en concreto cambiará el state de mi app.Cualquier cambio en el state debe ir englobaco en act()

					PASO 8 PUBLICAR EL PAQUETE

Lo primero será crear una cuenta en npm.Una vez creada hay que usar <npm login>.
Pedirá el username y la password y un email(puedo ver con npm whoami mi username)

Antes de publicar vamos a crear un commit,un push y una release-tag.
NOTA:fijate que esto no es necesario para publicar algo en npm,al publicar simplemente se cogerá ese código y se publicará,aunque obviamente,normalmente irá sincronizado con git.Una vez sincronizado ya si,publicamos

>npm publish
* New Version <- nada
IMPORTANTE: si veo que estoy logeado correctamente y me da error 403 probar con otro nombre.
Y recuerda que la OneTimePassword me vale el numero de MFA!

				VIDEO 120 NUEVA VERSION DEL PAQUETE

Para subir una nueva version Fernando recomienda estos pasos:

Una actualización se resume en:
1. Actualizar la carpeta SRC - Si aplica
2. Actualizar el example - Si aplica
3. Subir la versión en el package.json
4. Realizar la actualización en el repositorio local y remoto
5. Se recomienda crear un nuevo release tag
6. Ejecutar nuevamente el yarn publish

Sin embargo,el único no opcional es subir la versión(y recuerda que la propiedad name es fundamental).

NOTA: normalmente se usa 'rc' en las versiones.Ejemplo:
version: "1.0.0-rc" <- version release-candidate
Y cuando ya deja de ser candidata se quita el rc:
version: "1.0.0"
Es decir,que no suelen empezar desde la 0.0.1 sino desde la 1.0.0.

Puedo observar que no tiene nada actualizar un paquete.Ahora viene la parte interesante,que es usarlo xd

				VIDEO 121 USANDO NUESTRO PAQUETE DE NPM

Creamos una nueva app con la plantilla de typescript:
npx create-react-app@latest <name> --template typescript

Ya simplemente es copiar desde el registro,pues tengo tanto el import como un ejemplo de uso.Si quisiera probar la foto tendré que copiarla en la carpeta public

					SECCION 10 FORMIK REACT FORMS

Hay dos secciones de formularios.En ésta usaremos Formik.Si bien se pueden tratar los formularios manualmente,son demasiadas cosas que debería controlar, y por ello es mejor usar librerias de terceros como Formik.
Si bien al principio puede que no vea la mejora,al final de la sección veré una gran mejoría si uso Formik.
Formik recomienda usar Yup como validador

Esta es una sección muy importante para comprender las bases y temas avanzados de Formik, aquí veremos:
1- useFormik
2- Formik Component
3- Formik Context
4- useField
5- Formik Custom Components
6- Custom Components
7- Metadata de los inputs
8- Abstractation
9- Yup
   a- Validaciones tipicas
   b- Validaciones personalizadas

			VIDEO 125-126 INICIO DEL PROYECTO - FORMIK - FORMA TRADICIONAL

Abro la web de formik que proporciona Fernando y copio los styles que también proporciona.Creamos un componente RegisterPage con estos campos:
      <form>
        <input type="text" placeholder="Name" />
        <input type="email" placeholder="Email" />
        <input type="password" placeholder="Password" />
        <input type="password" placeholder="Repeat password" />
        <button type="submit">Create</button>
      </form>
Obviamente tenemos que gestionar este formulario.

					VIDEO 127 FORMA TRADICIONAL CON USE-STATE

Fijate que para saber el tipo de evento que recibo lo mejor es no fiarse y ver el evento que mando usando esta sintaxis:

 onChange={(e) => onChange(e)} <- me pongo sobre la 'e' y veré que es de tipo ChangeEvent<HTMLInputElement>

No uses la forma corta ni te pongas en otro lado.Ahora ya puedo escribir la función bien:

const onChange = (event: ChangeEvent<HTMLInputElement>) => {
  const { name, value } = event.target;
  setRegisterData({
    ...registerData,
    [name]: value
  });
}

Para controlar un input iempre es onChange + name,el value lo puedo usar,pero siempre tras haberlo controlado.
En el siguiente video vamos a crear un custom hook con todo esto.

					VIDEO 129 CUSTOMHOOK USE-FORM

Para crearnos nuestro customHook tengo que tener en cuenta la sintaxis para agregar un tipo a una arrow function( const <name> = <T>(args:T) => {}

Va antes de los argumentos,si fuera una function normal sería function useForm<T>(args:T) pero como es una arrow function se separa justo en el name:
const arrow_name = <T>(args:T)=> pero que asinto soy

IMPORTANTE: esta sintaxis sólo vale si el archivo es extensión .ts(no funciona con .tsx)

export const useForm = <T>(initialData:T) => {
/* seria lo mismo que esto */
// export function useForm<T>(initialData:T) {

  const [ formData, setFormData] = useState(initialData);

  const onChange = (event: ChangeEvent<HTMLInputElement>) => {
    setFormData((prev) => ({
      ...prev,
      [event.target.name]: event.target.value
    }));
  };

  return {
    ...formData,
    formData,
    onChange,
  }
}
Fijate que esparcimos el objeto para mayor comodidad.

				VIDEO 130 EXPANDIR FUNCIONALIDAD DE NUESTRO HOOK

Podemos expandir un poco más la funcionalidad mandando una función que resetee al valor inicial nuestro form.Pan comido:
 
 const reset = () =>{
    setFormData({...initialData});
  }
  return {
    ...formData,
    formData,
    onChange,
    reset <- la mando también
  }
Ya sólo faltaría llamarla cuando quiera.

IMPORTANTE:fijate que faltan las validaciones.Un formulario debe validar sus campos,da igual el framework,lenguaje...Fernando ya creó algunos estilos para esto,asi que podriamos hacer algo como esto:

  className={`${name.trim().length <= 0 && "has-error"}`} 
{ name.trim().length <=0 &&  <span>Este campo es necesario</span>}

De esta forma puedo controlar si hay un caracter o esta vacio,pero fijate que realmente son solo estilos,y además aún me quedaría comprobar que no se muestre ya desde un principio,con isTouched sobre ese campo.

Y para el email sería mucho más complicado.Si bien está la propiedad pattern Fernando deja un gist con una función validadora de un email mediante la interfaz RegExp:

  const isValidEmail = (email: string) => {
    const re:RegExp = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(email);
  }

Con esta función ahora podria comprobar el email y de nuevo validar
 className={`${!isValidEmail(email) && "has-error"}`}
  />
 {!isValidEmail(email) && <span>Email no válido</span>}

Podriamos crear tantas validaciones como queramos:

{password1.trim().length <= 0 && <span>Este campo es necesario</span>}
{password1.trim().length < 6 && password1.trim().length > 0 && <span>La contraseña es demasiado corta</span>}

Y para la otra password:
{password2.trim().length <= 0 && <span>Este campo es necesario</span>}
{password1 !== password2 && password2.trim().length > 0 && <span>Las contraseñas no coinciden</span>}

Aún me quedaría gestionar la clase y encima,realmente esto es solo para estilizar,va a hacer el posteo del formulario igual.También tendría que hacer las validaciones en el submit del formulario.
Es por esto que se usan librerias de terceros.

				VIDEO 131 FORMIK EJERCICIO BÁSICO

Fijate que podría seguir con la forma anterior,hacer el useForm superrobusto y subirlo a npm.
Sin embargo estamos aqui para ver como integramos Formik y además usando Typescript.Eventualmente crearemos nuestros propios formularios y hasta crear nuestros formularios dinámicamente en base a por ejemplo una respuesta http.Perfecto.

Bien,creo otra página con otro formulario:
      <h1>Formik Basic Tutorial</h1>
      <form noValidate={true}>
        <label htmlFor="firstName">First Name</label>
        <input type="text" name="firstName" />
        <span>First Name is required</span>

        <label htmlFor="lastName">Last Name</label>
        <input type="text" name="lastName" />
        <span>Last Name is required</span>

        <label htmlFor="email">Email Address</label>
        <input type="email" name="email" />
        <span>Email is required</span>
        <span>Check for an valid email format</span>

        <button type="submit">Submit</button>
      </form>

				VIDEO 132 OBTENER INFORMACIÓN DEL FORMULARIO

Si bien puede parecer al principio que no hay mucha diferencia llegará un punto en que notaré esa diferencia.
NOTA: las dos mejores librerias son formik y react-hooks-form.Debo dominarlas.

Bien,instalemos formik aqui:
npm i formik
Para trabajar con formik hay varias formas y hay que configurar un par de cosas.Vayamos poco a poco.Lo primero es importar su customHook useFormik:

import {useFormik} from 'formik';

*este hook espera un objeto por argumento,con dos propiedades,initialValues y onSubmit:

const formik = useFormik({
  initialValues:{},
  onSubmit:(values) => {console.log(values}

IMPORTANTE: formik también va a gestionar el onChange={e => handleChange(e.target.value)} y muchas otras features.Tan solo tengo que ir por cada input asi:
   <input 
     type="text"
     name="firstName" 
     onChange={formik.handleChange}
     value={formik.values.firstName
   />

Lo mismo para el value,lo tendré en formik.values.{fieldName}.Obviamente los names deben coincidir con las propiedades del initialState.
NOTA:fijate que los de formik han llamado a todas las funciones que ya me proveen con handleXXX(handleChange,handleSubmit,handleReset,...

Si ahora comprobara linea por linea con la implementación manual veré que es casi lo mismo,a excepción de donde situé el onSubmit(realmente solo cambia esto).Si bien parece que no hay mejora realmente tengo acceso a un sinfin de validaciones y métodos necesarios y que ya me proveen ellos.Muy interesante esta libreria.

				VIDEO 133 FORMIK VALIDACIONES MANUALES

Realmente dentro de este hook useFormik({}) tengo muchas más opciones aparte de initialValues y onSubmit,claro que estas son obligatorias,también se podría decir lo mismo de la función validate(values):errors:{} ( o validationSchema que ayuda mucho a que las validaciones sean mucho más legibles,suplantando a validate).

Pero empecemos por validate.Fijate que es una funcion que recibe los initialValues y devuelve un objeto de tipo FormikErrors<T> con los posibles errores.T será el tipo de los initialValues.Ejemplo:

* Sintaxis básica
  const validate = (values: FormValues) => {
    const errors: FormikErrors<FormValues> = {}

    return errors;
  }

Al final queda así:
const re: RegExp = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i;

const FormikBasicPage = () => {
  const validate = ({ firstName, lastName, email }: FormValues) => {
    const errors: FormikErrors<FormValues> = {};

    if (firstName.trim().length <= 0) {
      errors.firstName = "Este campo es necesario";
    } else if (firstName.trim().length > 15) {
      errors.firstName = "Este campo no puede tener más de 15 caracteres";
    }

    if (lastName.trim().length <= 0) {
      errors.lastName = "Este campo es necesario";
    } else if (lastName.trim().length > 10) {
      errors.lastName = "Este campo no puede tener más de 10 caracteres";
    }

    if (email.trim().length <= 0) {
      errors.email = "Este campo es necesario";
    } else if (!re.test(email)) {
      errors.email = "Invalid email address";
    }
    
    return errors;
  };

NOTA:fijate que es un tanto verboso.Sin embargo sigue siendo mejor que la forma manual,en la que tengo que definir las validaciones dos veces,con formik con una valdrá.Además lo resumiremos más adelante.
  Bien,si ahora trato de llamar al submite veré que ya gestionan ellos que si hay errores no se postee el formulario.Esto es otra ventaja también.
Claro que aún falta mostrar los errores condicionalmente.

			VIDEO 134 FORMIK - MOSTRAR ERRORES EN  LOS CAMPOS

Para mostrar los errores tengo que extraerlos de su hook también,pues me lo proporcionan ellos:

 const { handleChange, values, handleSubmit, errors} = useFormik();

Ya solo tengo que ir campo por campo mostrando el error condicionalmente:
   { errors.firstName &&  <span>{errors.firstName}</span>}

IMPORTANTE: el error debe llevar como texto la misma propiedad,ya que éste irá cambiando:
 {errors.lastName  &&  <span>{errors.lastName}</span>
}

Fijate que irá cambiando el texto del error:
    if (lastName.trim().length <= 0) {
      errors.lastName = "Este campo es necesario";
    } else if (lastName.trim().length > 10) {
      errors.lastName = "Este campo no puede tener más de 10 caracteres";
    }

Sin embargo,podemos comprobar que no está del todo correcto,al perder un foco un control no sale el error(isTouched) y encima me muestra los tres errores a la vez.Esto es normal,ya que se ejecuta toda la función validadora y sería una mejor experiencia de usuario ir validando sólo los campos que fueron tocados.

Obviamente esto tiene fácil solución,pues Formik también me proporciona 'touch
ed'desde su hook:
 const { handleChange, values, handleSubmit, errors, touched} = useFormik();

* Ya puedo mejorar esa lógica,mejorando la experiencia de usuario...
 { touched.firstName && errors.firstName &&  <span>{errors.firstName}</span>}

NOTA:sin embargo,puedo observar que falta algo,y ese algo es el handleBur,también debo manejarlo.Fijate que al usar Formik la propiedad name se vuelve imprescindible también,aunque realmente siempre lo es:
<input
   type="email"
   name="email"
   onBlur={handleBlur}
   onChange={handleChange}
   value={values.email}
   />

Si bien pudiera parecer que no estamos ganando nada,seguiremos avanzando con Formik y veremos como al final si que lo hacemos.

					VIDEO 135 YUP - VALIDATION SCHEMA BUILDER

Yup es un Javascript schema builder for value parsing and validation(un constructor de esquemas de validaciones).Un schema Yup es altamente expresivo.
Está inspirado en Joi,pero es para el cliente,en vez de para el backend.Usa funciones encadenadas al estilo jQuery.

Lo primero será instalarlo,que realmente debí instalar junto con formik
> npm i --save yup

NOTA: Formik recomienda Yup,pero puedo usar cualquier validación,como ya hemos visto con la nuestra.

Siempre me traeré toda la libreria:
import * as Yup from 'yup';

import * as yup from 'yup';

Formik ya me da la propiedad validationSchema para pasarle un schema:

 validationSchema:  yup.object().shape({
  name: yup.string().max(15).min(3).required(),
  age: yup.number().required().positive().integer(),
  email: yup.string().email(),
  website: yup.string().url(),
  createdOn: yup.date().default(function () {
    return new Date();
  }),
});

IMPORTANTE: en su documentación puedo ver todas las funciones que tiene.Fijate que los metodos aceptan un mensaje validador como argumento adicional,lo cual viene genial.Por ejemplo estas son algunas funciones para strings:

string.required(message?: string | function): Schema
string.length(limit: number | Ref, message?: string | function): Schema
string.min(limit: number | Ref, message?: string | function): Schema
string.max(limit: number | Ref, message?: string | function): Schema
string.matches(regex: Regex, message?: string | function): Schema
string.matches(regex: Regex, options: { message: string, excludeEmptyString: bool }): 

number.min(limit: number | Ref, message?: string | function): Schema
number.max(limit: number | Ref, message?: string | function): Schema
number.lessThan(max: number | Ref, message?: string | function): Schema
number.moreThan(min: number | Ref, message?: string | function): Schema
number.positive(message?: string | function): Schema
number.negative(message?: string | function): Schema
number.integer(message?: string | function): Schema

date.min(limit: Date | string | Ref, message?: string | function): Schema
date.max(limit: Date | string | Ref, message?: string | function): Schema

Con todo esto ya puedo mandarle un schema con mis mensajes propios:
      validationSchema: Yup.object().shape({
        firstName: Yup.string()
          .max(10, "debe de tener máximo 10 caracteres")
          .min(3, "debe de tener minimo 3 caracteres")
          .required("required"),
        lastName: Yup.string()
          .max(15, "debe de tener máximo 15 caracteres")
          .min(3, "debe de tener minimo 3 caracteres")
          .required("required"),
        email: Yup.string()
          .email('debe ser un email válido')
          .required('required'),
      }),
Fijate qué fácil lo deja todo esta librería.Eventualmente sacaremos de aqui este objecto para hacer validaciones dinámicas de formularios creados dinámicamente.

					136 FORMIK - GETFIELDPROPS

Que pereza ir por cada campo escribiendo ese onBlur,onChange,value,no?Debería haber una manera de hacer esto más sencillo,verdad?

Pues hay varias formas,empezaremos por la primera,que es usando la función getFieldProps,el cual se saca del hook también,claro.

const { ..., getFieldProps} = useFormik();

Ahora sólo hay que pasarlo por cada campo pasandole un name.Importante:fijate que el getFieldProps inclusive te establece el name:
    <input
      type="text"
      {...getFieldProps('firstName')} > <- no hace falta nada más

IMPORTANTE: el getFieldProps regresa un objeto(por eso tengo que desestructurarlo) el cual regresa el onChange,onBlur,value y name.Increible.

Fijate que esto hace que ya no necesite el handleChange,handleBlur y value del useFormik,lógicamente.Ni tampoco la interfaz o la expresión regular.Desde luego ha sido un paso muy importante para reducir código.
Pero aún se pueden reducir más cosas.

					VIDEO 137 FORMIK - COMPONENTES

En Formik tengo muchos componentes preconfigurados que ya me proporcionan ellos.Estos componentes me van a ayudar a reducir aún más el código

import { useFormik,Field,Form,ErrorMessage } from "formik";

Estos componentes en el background crearán un context con createContext.Usarán el patrón RenderProps,con el cual puedo devolver un hijo como una función que retorne el componente.

IMPORTANTE: fijate que usar el HOC <Formik> internamente llamará al useFormik,y por ello no tengo que llamarlo explicitamente:
Puedo ver que me devuelve un JSX:

(alias) function Formik<Values extends FormikValues = FormikValues, ExtraProps = {}>(props: FormikConfig<Values> & ExtraProps): JSX.Element

NOTA: <Formik> necesita ciertos atributos,incluso puedo autocompletarlos:

<Formik >
{ formik => (<Form>...</Form>)}
</Formik>

Puedo ver que me pide los children,los initialValues,validationSchema y onSubmit,obviamente para pasarselo al hook.Asi que ya puedo borrar el hook.
Obviamente gestionar esto con sus componentes ya lo convierte en un juego de niños:

<Formik initialValues={{...}} onSubmit={...} validationSchema={{Yup.object()}}>
 {({ touched, errors }) => (
          <Form>
            <label htmlFor="firstName">First Name</label>
            <Field type="text" name="firstName"
              className={
                touched.firstName && errors.firstName ? "has-error" : ""
              }
            />
            <ErrorMessage name="firstName" />

Fijate que puedo pasar a los children todas las propiedades que ya tenia acceso antes con el hook(recuerda que <Formik> llama a useFormik),asi que las paso a los hijos.Form no necesita onSubmit,pues estamos en un contexto aislado,efímero y local.Field sólo necesita el name,lo mismo que ErrorMessage.Increible.

NOTA:puedo ver que ErrorMessage pintará un simple string por pantalla.Para poder estilizarlo como lo teniamos antes tengo que decirle que es un span.Lo puedo hacer con la propiedad component:
<ErrorMessage name="firstName" component="span"> <- podria pasasrle div | p ...
En cuanto le diga que es un span cogerá la regla de estilos que apuntaba a los span.

Todavía nos queda ver que pasa con un checkbox o un select,que son tags imprescindibles en formularios.Lo importante de este video era entender que Formik crea un contexto y que llama al hook entre bambalinas,etc...

			VIDEO 138 FORMIK - SELECTS Y INPUTS TYPE CHECKBOX

Realmente en un formulario habrá textareas,checkbox,cajas de selección(selects)...Hay que tener en cuenta que Field por defecto va a pintar un input type text,pero le puedo pasar la propiedad as="type" con otros valores(textarea | select ):

Ejemplos y lo que sería su representación en HTML
// <textarea className="form-textarea"/></textarea> 
 <Field name="message" as="textarea" className="form-textarea" />
 
 // <select className="my-select"/>
 <Field name="colors" as="select" className="my-select">
   <option value="red">Red</option>
   <option value="blue">Blue</option>
 </Field>

// <input type="checkbox">
 <label>
    <Field type="checkbox" name="terms" />
     Terms and Conditions
 </label>

Bien,realmente sólo sería agregar dos campos más,con sus validaciones:
  <Formik
        initialValues={{
          firstName: "",
          lastName: "",
          email: "",
          terms:false,
          jobType:''
        }}

Si por ejemplo quiero que acepten el checkbox:
  terms: Yup.boolean().oneOf([true], "debe aceptar los términos"),
En cuanto al select con required puede valer:
    jobType: Yup.string().required("debe seleccionar una opción"),

Fijate que esto hace que no haga match la <option value="">,tiene que tener un value la opción.Asi que puedo poner una sin valor:
  <Field as="select" name="jobType"  >
     <option value="">Select One...</option> <- está no pasará el required
     <option value="developer">Developer</option>
     <option value="designer">Designer</option>

Si además quisiera filtrar valores lo puedo hacer de nuevo con oneOf([]) o notOneOf([]).Siempre llevan un arreglo de valores y el feedback:

  jobType: Yup.string()
    .required("debe seleccionar una opción")
    .notOneOf(['it-junior'],'no puede ser IT-Junior'),

Desde luego esta libreria es un must-know en React.

			VIDEO 139 FORMIK - ABSTRACTION USE-FIELD

Todavia podriamos tomar el validationSchema y sacarlo del código a otro punto del mismo archivo o incluso a otro.Eventualmente lo haremos,pero de momento fijemonos en este patrón repetitivo:

<label ...>
<Field ...
<ErrorMessage...>

Puedo observar que se repite mucho,se repite para cada control.Siempre que se repite código en teoría hay una manera de abstraerlo para no repetirlo.Lo que vamos a hacer se encuentra en la documentación oficial de Formik.

Bien,creemos un custom inputField que permite resumir esos tres elementos en uno sólo.Formik permite traer mediante un customHook llamado useField las propiedades del contexto del formulario(recuerda que Formik llama a createContext al usarse asi <Formik></Formik> o bien con useFormik,da igual,pues es lo mismo).

Realmente es bastante sencillo,habrá que declarar una interface con lo que quiera pasar a mi componente,en este caso como va a suplantar al <label>,<input> y <ErrorMessage podría ser algo asi:

interface Props {
  label: string,
  name: string,
  type?: "text" | "email" | "password",
  placeholder?: string,
  id: string,
  [x:string]:any,
}
Ahora tipo las props y las paso al hook suyo.
const MyTextInput = (props: Props) => {

  const [field, meta] = useField(props);
Con estas props se las mando a su hook y de alli puedo sacar el field(name,placeholder,type,... y la metadata.En la metadata tendré si ha sido tocado,si hay errores,...

Sabiendo todo esto ya puedo crear la label,con el htmlFor apuntando al id si viene y sino al name y con el input recogiendo todos los fields y las props que pueda querer mandar(fijate en el uso de [x:string]:any):

      <label htmlFor={props.id || props.name}>{label}</label>
      <input {...field} {...props} />

Y por último compruebo mediante ese objeto meta que las condiciones para mostrar los errores sean touched y hasError,como siempre:

 {
     meta.touched && meta.error && (
          <span className="error">{meta.error}</span>
)}

NOTA: definir una prop asi la hace opcional por naturaleza([x:string]:any)
Ahora si,ya puedo usar mi custom Component:

<MyTextInput
      label="First Name"
      name={"firstName"}
      placeholder="First Name"
    />

    <MyTextInput
      label="Last Name"
      name={"lastName"}
      placeholder="Last Name"
    />
    <MyTextInput
      label="Email"
      type="email"
      name="email"
      placeholder="Email"
  />
Puedo aprovecharme que son text por defecto,etc.Mucho más fácil y sencillo.Puedo observar que mediante ese hook useField(props) le estoy pasando correctamente todo,el onChange,el onBlur,los values,touched,errors,...
Desde luego es una abstracción muy útil,aunque falta ver como hacer lo mismo con los select o checkbox...

					VIDEO 140 CUSTOM SELECT

La diferencia será que tiene as="select",aunque como va a ser otro Componente especializado para Select no hará falta.Lucirá asi:

interface Props {
  label: string;
  name: string;
  id?: string;
  [x: string]: any;
}

/* {label, ...rest} <-operador rest asi { ...rest} vuelve a juntar,asinto,por eso luego las puedo esparcir */
const MySelect = ({label,...props}: Props) => {
  const [field, meta] = useField(props);

  return (
    <>
      <label htmlFor={props.id || props.name}>{label}</label>
      <select {...field} {...props} />
      {meta.touched && meta.error && (
        <span className="error">{meta.error}</span>
      )}
    </>
  );
};

*La pregunta es,donde están los values o los options??Realmente no hace falta pasarlos,simplemente debo usar este componente englobando a los <options>:

 <MySelect label="Choose your job Type" name="jobType" >
      <option value="">Select One...</option>
      <option value="developer">Developer</option>
      <option value="designer">Designer</option>
      <option value="it-senior">It Senior</option>
      <option value="it-junior">It Junior</option>
  </MySelect>
Se le puede pasar multiple a true o disabled,hay que cambiar los initialValues y las validaciones en tal caso

				VIDEO 141 FORMIK CUSTOM CHECKBOX

Es prácticamente igual,salvo que el label no necesita el htmlFor:

const MyCheckbox = ({ label, ...props }: Props) => {
  const [field, meta] = useField({...props,type:'checkbox'});

  return (
    <>
      <label >
      <input type="checkbox" {...field} {...props} />
        {label}
      </label>

				VIDEO 142 PEQUEÑAS OPTIMIZACIONES

PRIMERA: La primera refactorización que vamos a hacer es arreglar esto:
import MyCheckbox from "../components/MyCheckbox";
import MySelect from "../components/MySelect";
import MyTextInput from "../components/MyTextInput";

Puedo ver que todos ellos vienen del mismo paquete.Esta vez sólo son tres,pero podrian ser 8 o 15.La manera más fácil de hacer esto es crear un index.ts en el directorio correspondiente y exportarlo:

export { MyCheckbox } from "./MyCheckbox";
export { MySelect } from "./MySelect";
export { MyTextInput } from "./MyTextInput";

Ojo,que esto necesita named exported en los componentes:

import { MyCheckbox, MySelect, MyTextInput } from "../components";

Siempre debo importar con nombre,es mucho mejor despues,a no ser que requiera lapor default.

SEGUNDA: realmente no es necesario usar la parte del meta al usar useFields:
  const [field ] = useField(props);
     <>
      <label htmlFor={props.id || props.name}>{label}</label>
      <select {...field} {...props} />
      <ErrorMessage name={props.name} component="span" />
    </>
Sin embargo,debo recordar que existe,y que podria acceder al tipo de error mediante él o al touched,en vez de usar ErrorMessage(que ya lo gestiona sólo)

TAREA: arreglar esto:
import FormikAbstraction from "../03-forms/pages/FormikAbstraction";
import FormikBasicPage from "../03-forms/pages/FormikBasicPage";
import FormikComponents from "../03-forms/pages/FormikComponents";
import FormikYupPage from "../03-forms/pages/FormikYupPage";
import RegisterPage from "../03-forms/pages/RegisterPage";


