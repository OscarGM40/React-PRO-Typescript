					SECCION 11 FORMIK DYNAMIC Y CUSTOM FORMS

Esta seccion tiene por objetivo construir formularios dinámicos,por ejemplo desde un backend mandando un JSON.Será un archivo pues el que defina el formulario.

Esta sección tomaremos el conocimiento aprendido sobre Formik y crearemos formularios dinámicos basados en data en formato JSON. Aquí aprenderemos:

1- Construir inputs de forma dinámica
2- Construir validaciones basados en propiedades
3- Selects, Inputs
4- Ideas para validaciones

Es una sección corta, pero bastante solicitada, el objetivo principal de la misma es que tengamos la idea de formularios dinámicos y que logremos adaptarlo a nuestras necesidades particulares.

					VIDEO 147 TAREA REGISTER FORM CON FORMIK

Copiamos el register y la tarea es pasar todo a Formik.
NOTA:fijate que el onSubmit puede ser asincrono sin ningun problema:
   onSubmit={ async (values) => await ...}

IMPORTANTE: para hacer referencias a otros controles se usa Yup.ref('fieldName'):
  password2: Yup.string()
    .required("Required")
    .min(6, "Must be 6 characters or more")
    .oneOf([Yup.ref("password1"), null], "Passwords must match"), 

Para resetear ya me dan la funcion handleReset,aunque yo usé la propiedad resetForm:
  <button type="button" onClick={() => formik.resetForm()}>

					VIDEO 148 FORMULARIOS DINÁMICOS

El objetivo de los formularios dinámicos es que realmente sean dinámicos,es decir,que sean creados en tiempo de ejecución,al recibir el json.

Como ese JSON puede lucir de cualquier forma,habrá que crear un standar con las bases.Por ejemplo,un input puede lucir asi:
[
  {
    "type":"input",
    "name":"firstName",
    "placeholder":"Enter First Name",
    "label":"First Name",
    "value":""
  }
]

Ya sólo es traerlo al Javascript.Obviamente faltan los demás campos y en la realidad esto será la repuesta http de un backend...:
import formJson from './../data/custom-form.json';

Realmente iterar sobre este json es muy fácil:
  {(formik) => (
          <Form>
            {formJson.map( (field) => {
              return (
                <MyTextInput
                  key={field.name}
                  type={field.type as any}
                  label={field.label}
                  name={field.name}
                  placeholder={field.placeholder}
                />
              );
            })}
Lo dificil va a ser sacar los initialValues de forma dinámica.

			VIDEO 149 CREANDO EL INITIAL VALUES DE FORMA DINÁMICA

Fijate que al no tener los initialValues tengo el error de que React intenta controlar un componente no controlado.Esto es porque faltan los initialValues.
Si bien fernando usó un ciclo for of con un map sin retornar nada también vale:

const initialValues:{[x:string]:any} = {};

formJson.map( (field) => {
  initialValues[field.name] = field.value;
})
Fijate que especificar que las propiedades van a ser cualquier key de tipo string es muy correcto => { [x:string]: any } <- any porque pueden ser numeros o booleans

Bien,ahora que sabemos cargar los initialValues dinámicamente falta ver como cargar un <select> u otro tipo de control:

				VIDEO 150 CARGAR SELECTS DE MANERA DINÁMICA

EL JSON para el select va a ser un poco diferente,ya que tendrá un campo options y no lleva placeholder,claro:
  {
    "type": "select",
    "name": "favoriteGame",
    "label": "Favorite Game",
    "value": "",
    "options": ["League of Legends", "Fortnite", "Overwatch", "Dota 2"]
  }
NOTA:fijate que input type="input" crea un input type="text".Esto nos vino genial.Es importante entender que lo importante sería estandarizar la entrada por JSON,obviamente debe ser la misma.

En este punto ya no puedo devolver otro input,debo determinar el tipo de control primero:
   {formJson.map( (field) => { return ( <MyTextInput <- necesito saber el tipo

Fijate que nunca deberia ver este span:
 return <span>Type: {type} no es soportado</span>

Al final es igual de sencillo que los demás:
   if (type === "select") {
    return (
      <MySelect key={name} name={name} label={label}>
        {options?.map((option) => (
    <option key={option.id} value={option.label}>
      {option.label}
    </option>
        ))}
      </MySelect>

Por último,necesitamos las validaciones dinámicas también.En este punto podria usar validate o validationSchema con Yup.

				VIDEO 151 VALIDACIONES DINÁMICAS

Obviamente,solo se trata de añadir un campo más,aunque será un arreglo de objetos,pues puede haber muchas validaciones:

  {
    "type": "input",
    "name": "firstName",
    "placeholder": "Enter First Name",
    "label": "First Name",
    "value": "Fernando",
    "validations": [
      {
        "type": "required",
        "message": "First Name is required"
      }
    ]
  },

Ahora viene lo dificil que es automatizar esto:

const initialValues: { [x: string]: any } = {};

const requiredFields: { [x: string]: any } = {} as unknown as any; 

formJson.map((field) => {
  initialValues[field.name] = field.value;
  
  let schema = Yup.string();

  if (field.validations !== undefined) {
    for(let rule of field.validations) {
      if(rule.type ==="required"){
        schema = schema.required(rule.message);
      }else if (rule.type === "minLength") {
        schema = schema.min((rule as any).value || 1, rule.message);
      } else if (rule.type === "email") {
        schema = schema.email(rule.message);
      }

    }

    requiredFields[field.name] = schema;
  }

});

const validationSchema = Yup.object().shape({...requiredFields});

Puedo observar que quitando un par de zonas dificiles es bastante sencillo crear formularios dinámicos y,desde luego,parece bastante útil.

Claro que aun faltan muchas cosas,de momento queda asi.Crear nueva rama y dejarla como 'dynamic-forms'.

SECCION 12 STORYBOOK-CAMA PARA CREACIÓN Y MANTENIMIENTO DE COMPONENTES Y PAQUETES

Puedo imaginar STORYBOOK como una mesa de construcción,en la cual puedo construir componentes.Empieza como una aplicación de React,pero no termina siendo eso,
sino que es una zona para construir componentes.
No sólo eso,sino que puedo jugar con esos componentes,mandarles propiedades,generar documentación automatica,compartir los componentes mediantes enlaces http.

Esta sección está enfocada en aprender como integrar Storybook en nuestras aplicaciones de React para transformarla en una aplicación que nos ayudará a probar y desarrollar de una mejor manera nuestros componentes.

La sección tiene por objectivo aprender:

1- Integrar Storybook en una aplicación de React con Npx
2- Crear un componente desde cero
3- Crear historias
4- Configurar historias
5- Utilizar varios controles para las properties
6- Integración con TypeScript
7- Crear documentaciones de componentes
8- Desplegar documentación a diferentes sitios
9- Bonus: Chromatic para desplegar Storybook de forma colaborativa

				VIDEO 156 INICIO PROYECTO - MY STORYBOOK -

IMPORTANTE: Storybook(https://storybook.js.org/) no es algo que esté ligado a un framework en concreto.Puedo usar React,Angular,HMTL,Vue,Ember,...

Lo primero que hay que hacer es crear una aplicación de React(investigar Vite y NextJS):
npx create-react-app <name> --template=typescript

NOTA: con storybook se trata de crear componentes,no aplicaciones,para despues compartirlos o guardarlos.

			VIDEO 157 INSTALAR Y CONFIGURAR STORY-BOOK EN LA APP

Para añadir storybook debo ejecutar npx sb init(no admite un proyecto vacio):
>npx sb init
NOTA:el comando vale para todos los frameworks.
Esto crerá ciertos componentes de demostración,asi como la cama para manejarlos,etc.Pero antes de ejecutarlo primero hay que limpiar varios archivos y directorios:

NOTA: podriamos haber usado npm eject,pero crea muchos archivos
UNO: Primero ejecuto esto
npm remove react-scripts
DOS: Despues borro todo(carpeta public y todos los files menos el src/index.tsx(seguir video)
TRES:ahora si,ya puedo ejecutar npx sb init(tarda un rato)
* puedo ver que puedo ejecutar npm run storybook

CUATRO: antes de ejecutarlo repasemos los cambios.TEngo una nueva carpeta '.storybook' con dos files main.js y preview.js.Son archivos de configuración para agregar addons,plugins,etc para storybook.

También creó un folder 'stories' con varios componentes(cada uno formado por button.css,Button.stories.tsx y Button.tsx).Es decir el componente,sus estilos y un archivo .stories.tsx

CINCO:puedo ver dos nuevos scripts en el package.json:
  "storybook": "start-storybook -p 6006",
  "build-storybook": "build-storybook"
Obviamente,uno es para hacer el build y otro para correr la aplicación(levanta storybook en ese puerto).
IMPORTANTE:los comandos con react-scripts ya no me valen asi que puedo dejar estos dos,o renombrarlos,etc..

Por último limpio el index.ts ya que tampoco tengo el index.html y no me vale ese código.Ejecuto npm run start | storybook y debería abrirse su interfaz web.

			VIDEO 158 MODULOS DE CSS Y LEVANTAR STORYBOOK

Fijate que Fernando tenia problemas al levantar la app.Le pedia instalar postcss,entre otras cosas(parece que ya lo corrigieron).
Fernando deja un gist con esto:
gist: https://gist.github.com/Klerith/c82cbe0c4733184deaddf3421e8acff5

PASO UNO 
yarn add -D @storybook/addon-postcss postcss css-loader

PASO DOS: en el .storybook.main.js:
module.exports = {
  addons: [
   {
    name: '@storybook/addon-postcss',
    options: {
      postcssLoaderOptions: {
        implementation: require('postcss'),
      },
    },
  },
  
  ]
}
PASO TRES: crear el postcss.config.js:
module.exports = {
  // Add your installed PostCSS plugins here:
  plugins: [
    // require('autoprefixer'),
    // require('postcss-color-rebeccapurple'),
  ],
};

IMPORTANTE: tras levanta exitosamente storybook puedo ver el contenido del  componente Introduction.stories.mdx por pantalla.Esta extensión es MarkDown + XML
Este lenguaje MDX juntará MarkDown junto a tags xml(<></>).

Bien,en la interfaz puedo cambiar todas las props que se definan en código,en este caso,tres tamaños,el color,el texto de la label y poco más.

NOTA:los comentarios también se reflejan en la interfaz web,asi que puedo y debería documentar el componente:

interface ButtonProps {
  /**
   * Is this the principal call to action on the page?
   */
  primary?: boolean;

					VIDEO 159 COMPONENTE MY-LABEL

Recuerda que esta app está creada para crear y testear este tipo de componentes,despues subirlos a GitHub y/o desplegarlos a Npm.

IMPORTANTE: Button sería una story y Primary como una página.Asi que minimo necesito una story con su primera página:

import MyLabel from '../../components/MyLabel';

export default {
  title: 'YourComponent',
  component: MyLabel,
};

const Template = () => <MyLabel />;

export const Basic = Template.bind({});
export const AllCaps = Template.bind({});

IMPORTANTE: Template.bind({}) rompe la referencia.Esto es necesario ya que en JS todo va por referencia.Es la única forma de que sean componentes diferentes.

En cuanto a la jerarquia de archivos todo depende del title:
export default {
  title: 'UI/Etiquetas/MyLabel',
  component: MyLabel,
};
Esto meterá las páginas en UI/Etiquetas/MyLabel/... lo cual tiene más sentido que el Example/Button que me dan.

		VIDEO 160 AÑADIR PROPS Y CONTROLES A NUESTRA HISTORIA Y COMPONENTE

Añadir props realmente no es nada que no sepa ya:

interface LabelProps {
  label: string;
  size: "normal" | "h1" | "h2" | "h3";
}

const MyLabel = ({ label = "No Label", size = "normal" }: LabelProps) => {
  return <span className={`label ${size}`}>{label}</span>;
};

Sin embargo,esto va a obligar a usar las clases ComponentMeta<T> y ComponentStory<T> de esta forma:

export default {
  title: 'UI/Etiquetas/MyLabel',
  component: MyLabel,
} as ComponentMeta<typeof MyLabel>

const Template: ComponentStory<typeof MyLabel> = (args) => <MyLabel {...args}/>;

Ahora ya no veré el error de TS sobre los args.Y si voy a la interfaz ya puedo elegir el font-size de entre los que he estilizado y establecer el texto de la label dinámicamente.

Sin embargo,puedo ver que faltan muchas cosas,como que venga con valores por defecto.Esto lo lograŕe tras romper la referencia al componente con Template.bind({})  ya que por ejemplo la label AllCaps debería estar en mayúsculas :

export const Basic = Template.bind({});
Basic.args = {
  label: 'Basic',
  size: 'normal',
}

export const AllCaps = Template.bind({});
AllCaps.args = {
  label: 'ALL CAPS',
  size: 'normal',
}
	
			VIDEO 161 DOCUMENTAR AUTOMÁTICAMENTE LAS DESCRIPCIONES

Todavia faltaría crear un documentación.Ya hemos visto como se hacia.Fijate que una buena documentación será fundamental.
NOTA: la documentación va en la interface que tipa el componente

IMPORTANTE: para storybook un comentario es insignificante asi que no va a re-buildear todo.Para ver los cambios tendré que cambiar algo del código o reiniciar el server.

			VIDEO 162 TAREA PROPIEDADES Y CONTROLES ADICIONALES

Realmente no tiene mucho,todo depende de lo que quiera,estilizarlo:

export const Basic = Template.bind({});
Basic.args = {
  size: 'normal',
  allCaps: false,
  color: 'primary'
}

export const AllCaps = Template.bind({});
AllCaps.args = {
  label: 'ALL CAPS',
  size: 'normal',
  allCaps: true,
  color: 'primary'
}

export const Secondary = Template.bind({});
Secondary.args = {
  label: 'Secondary',
  size: 'normal',
  color: 'secondary'
}

export const Tertiary = Template.bind({});
Tertiary.args = {
  label: 'Tertiary',
  size: 'normal',
  color: 'tertiary'
}
* En el componente
const MyLabel = ({
  label = "No Label",
  size = "normal",
  color = "primary",
  allCaps = false,
}: LabelProps) => {
  return (
    <span
      className={`label ${size} text-${color} ${allCaps ? "uppercase" : ""}`}
    >
      {label}
    </span>
  );

IMPORTANTE: no es buena idea dejar todo como sale por la interfaz web,ya que saca siempre <input type="checkbox">.Esto obviamente no es siempre lo que querré.
Storybook trata de hacer lo mejor posible,si el campo es un boleano pone un selector de true,false pero siempre puedo usar el selector que yo quiera con la propiedad argTypes:

				VIDEO 163 NUEVA PROPIEDAD - COLOR DE FUENTE

Es una tarea en la que meter un <input type="color">.Realmente es muy sencillo,simplemente le paso el control de tipo color en los argTypes:

fontColor: { control: 'color' }
Y la nueva página será un h1
export const CustomFontColor = Template.bind({});
Tertiary.args = {
  label: 'Custom Font Color',
  size: 'h1',
  fontColor: 'tertiary'
}

Lo más fácil es usar un estilo en línea:
 style={{ color: fontColor }}

				VIDEO 164 DESPLEGAR STORYBOOK A SERVIDORES

Digamos que ya tengo listo el componente y lo quiero subir a la Cloud.También veré como aprobar o cancelar cambios de manera colaborativa en Storybook.

						PASOS A SEGUIR

UNO: hacer el build(comando build-storybook).Esto crea la carpeta storybook/static con un index.html a servir.Esta es la carpeta importante.
Puedo hacer una prueba con la libreria http-server(npm i -g http-server)
live-server storybook-static --port=3000(usaré live-server)

DOS: desplegarlo(puedo arrastar esa carpeta en Netlify,por ejemplo).

Como puedo observar no puede ser más fácil desplegar un componente con storybook(fijate que creó un index.html)

				VIDEO 165 GITHUB Y GITHUB PAGES

Este despliegue no es opcional ya que en la siguiente ección vamos a ver despliegues automáticos con GitHubActions.
Asi pues creo un repo,se recomienda que sea público para aceptar PRs

NOTA: no debo subir esta carpeta asi que tengo que ignorarla.No tiene sentido subirla ya que se va a generar mediante un despliegue automático:
/storybook-static

Lo que si que hago es cambiarle el nombre de la carpeta a docs asi ya puedo configurar GitHub Pages.

					VIDEO 166 BONUS: CHROMATIC 

La integración de Storybook con Chromatic es muy buena.Es una herramienta colaborativa .Bien,hago el signup con GitHub y eligo entre crear nuevo proyecto o elegirlo desde GitHub.
Eligo el repo recién creado.

PASOS PARA USAR CHROMATIC EN UN PROYECTO
UNO:habrá que instalar en modo dev el paquete chromatic en el proyecto:
npm i -D chromatic

DOS: publicar el storybook mediante chromatic con el token único que tiene cada proyecto:
npx chromatic --project-token=8801b679c19d

Debería de haber podido publicar una Storybook con Chromatic

			VIDEO 167 CHROMATIC - ATRAPAR CAMBIOS EN LA UI

Vamos a hacer algun cambio en nuestro storybook para analizar que sucede en Chromatic.Levanto storybook en local y realizo algun cambio,por ejemplo un custom color para el background:

export const CustomBackgroundColor = Template.bind({});
CustomBackgroundColor.args = {
  label: "Custom Font Color",
  size: "h1",
  fontColor: "#5517ac",
  backgroundColor: "#000"
};

Una vez vea en local que está todo correcto puedo hacer el re-deploy a chromatic con el mismo comando(npm run chromatic).Hay que hacer el push a GitHub antes.

Bien,esto creará un segundo Build en chromatic(fijate que puedo invitar a teammates).Voy a ese segundo Build y debo revisarlo(review changes).Fijate que puedo crear usuarios y roles en chromatic.
Veré los cambios y puedo agregar marcadores con texto,muy útil,ya que podrá crear un marcador cualquier colaborador.
Esto es sólo una pincelada de Chromatic,parece una buena librería colaborativa para usar con storybook,aunque parece que hay que pagar por las features mas interesantes.

SECCION 13 GITHUB ACTIONS+SEMANTING VERSIONING+AUTOMATING NPM DEPLOY+STORYBOOK

Esta sección tiene por objetivo automatizar este workflow,de forma que con un sólo push o un PR se recorra todo el workflow:

Subir a Github los cambios
Crear release-semántico
Transferir esta release a npm (npm publish)

Esta sección es genial, aprenderemos lo siguiente:
1- Tomar nuestros componentes probados con Storybook
2- Generar los archivos de definición de TypeScript
3- Generar el build de producción
4- Crear una acción en Github actions para crear el versionamiento semántico
5- Usar el versionamiento semantico para publicar la version del paquete
6- Publicar el paquete en NPM
7- Actualizar paquete
8- Consumir el paquete en aplicaciones externas.

			VIDEO 171 CONTINUACION DE LA SECCION - EDITING PACKAGE.JSON

Bien,recuerda que tengo que poner private a false para desplegar un proyecto.

IMPORTANTE: a la hora de desplegar un paquete es buena idea que me tome algo de tiempo y dejar todo correcto.La propiedad typings(o types)  indicará los archivos de definición de tipos,main el punto de entrada,homepage o repository son metadata muy importante y license,private,versión,...todo es importante.

Seguiré con la propiedad release que apunta a un arreglo de ramas y files que apunta a un arreglo de directorios o archivos(ambos se admiten).Fijate:
  "release":{
    "branches":["master"]
  },
  "files":[
    "dist",
    "src"
    "package.json"
    "README.md"
  ],

Esto es la base de casi cualquier deploy,pero a nosotros aún nos faltan ciertas configuraciones por estar usando TypeScript.

			VIDEO 172 TSCONFIG.JSON - CONFIGURACIONES PARA TYPESCRIPT

IMPORTANTE: debo tener typescript de manera global.Puedo saber si lo tengo tratando de sacar la version del compilador(tsc --version).Instalar en global con :
npm i -g typescript ó yarn global add typescript

Bien,hay varias propiedades a configurar o añadir:
"outDir":"dist"
"declaration":true <- fijate que ésta es vital,ya que genera los d.ts
"noEmit:false <- estaba en true,mientras esté en true no emite archivos
 
 "include": [
    "src"
  ]
} <- debo asegurarme que está la propiedad incluce haciendo pinpoint correctly

Bien,hacemos el compilado con 'tsc' y vemos que hay algunos errores por no haber exportado las interfaces ni nosotros ni los de storybook.

IMPORTANTE: recuerda que ni el CSS ni las imagenes se van a mover solas.TSc sólo va a transpilar el TS a JS,nada más.Aún queda este trabajo por hacer.

		VIDEO LIMPIAR-COPIAR ARCHIVOS NECESARIOS AL FOLDER DIST

Vamos a usar dos librerias bastante usadaspara remover carpetas y copiarlas.Son 'rimraf'(para borrar directorios y su contenido) y 'copyfiles'(para copiar archivos masivamente).
Fijate que no puedo limpiar con rm -rf pues otro usuario podría estar en Windows o Mac,no puedo usar comandos nativos del SO:

yarn add -D rimraf copyfiles

Creo el script "clean" que eliminará la carpeta
"clean":"rimraf dist/"
Y lo llamo en el script "build",que hará todo en un único comando:
"build":"yarn clean
Bien,lo siguiente es copiar los .css:
"copy-files":"copyfiles --up 1 src/**/*.css dist/"
Lo agrego al comando main:
"build":"yarn clean && tsc && yarn copy-files"

Perfecto.Puedo ver que copió los css al lugar adecuado,respetando su ubicación orginal.

IMPORTANTE: un paso que se dejó Fernando es definir las peerDependencies,que son dependencias necesarias en el equipo para ejecutar este proyecto.En este caso pedimos simplemente cualquier version de React mayor a 16.8 y typescript v4+:

  "peerDependencies": {
    "react": ">=16.8.0",
    "typescript": ">=4.0.0" <- al final la quitamos
  },

				VIDEO 174 SEMANTIC VERSIONING AUTOMÁTICO

El manejo manual del versionamiento semántico es una de las cosas más molestas qeu suele haber.
NOTA:viendo el proyecto de Stephen veo que puedo usar "typings" o "types" como propiedad para los d types( "types": "./build/index.d.ts",)También observo que usó una licencia ISC(  "license": "ISC",) en vez de MIT.
El comando npm version <update_type> aumenta el numero de version(patch | major | minor) en base al type que le pase(npm version patch irá 1.0.1,1.0.2,1.0.3...)

En este punto Fernando sugiere usar la libreria npm 'semantic-release' y además agregarle ciertos plugins para expandir funcionalidades(opción totalmente recomendada,ya que generará releases y deploys a npm automáticamente):

>npm i -D semantic-release o yarn add semantic-release -D

Usar estos plugins para trabajar con Semantic Versioning(ya vienen instalados en el paquete anterior):
En el package.json agregar la propiedad "plugins" con:

"plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    "@semantic-release/github",
    "@semantic-release/npm",
    "@semantic-release/git"
],

NOTA: fijate que instalar este paquete en desarrollo no influirá en nada en el paquete que se instalará el usuario de esta librería.Lo que si que se instalará son todas las dependencias normales al instalar esta libreria custom.

En teoría ya está instalado,y fijate que la carpeta dist la debo subir,no puede estar ignorada.Bien,esta libreria trabaja en base a palabras clave que haya en el commit,por ejemplo:
git commit -m "feat: agregado semantic-versioning" <- esto subirá a 1.1.0

			VIDEO 175 CONFIGURACION DE TOKENS DE ACCESO

Puedo generar tokens de acceso desde GitHub.Los tengo el settings/developerSettings y alli puedo generar tokens para acceso programático.

Genero uno,lo etiqueto semánticamente y se recomienda darle una fecha de expiración y no usar Sin limite(eligo 90 dias)
En cuanto al scope de acceso solo necesita acceder al repo.Lo genero y lo guardo 

De igual manera voy a necesitar otro token en npmjs.com.También está en settings.Ojo,este token de npm debo darle acceso a publicar(publish)

Bien,ahora si,recuerda que estos tokens son para autenticar y autorizar la GitHubAction,y obviamente usaremos variables de entorno en el repo.Podemos ir haciendolo ya.
NOTA: recuerda que un secret en GH va a ir encriptado(igual que en cualquier otro lado,asinto).Los llamamos GH_TOKEN y NPM_TOKEN.

					VIDEO 177 GITHUB ACTIONS

GitHub Action es una tool poderosísima para realizar una gran cantidad de tareas automáticas.Vamos a Actions en el repo y creamos una desde scratch.
La dejamos como main.yml.Fernando provee un gist al yaml:
https://github.com/Klerith/sb-components/blob/main/.github/workflows/main.yml

Bien,analicemos el yaml:
# This is a basic workflow to help you get started with Actions

name: Semantic Release CI-CD

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]

jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Acceso al repo
      - uses: actions/checkout@v2
     
      - name: Setup Node.js
      - uses: actions/setup-node@v1
        with:
          node-version: 14.17
          yarn: true 
      
      - name: Instalar dependencias
        run: yarn install

      - name: Builder la App
        run: yarn build

      - name: Semantic Release
        env: 
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: npx semantic-release

Puedo ver que se trajo una version de Node con uses: actions/setup-node@v1 + with
y que para ejecutar npx semantic-release necesitamos los dos tokens de acceso programático.

NOTA:recuerda que los mensajes de commit deben tener una keyword(fix==patch release,feat==minor release,perf == major release).Asi que hacemos un commit con una de ellas:
git add .
git commit -m "feat: github actions configurado"

Ahora si,al hacer el push se disparará la acción.

			VIDEO 177 CONTINUACIÓN - ACTUALIZAR VERSIÓN Y PAQUETE

En este punto es muy común tener errores,un simple espacio mal dará un error.Fijate que yo tuve uno con un '-' y otro con el nombre de los secretos.

IMPORTANTE:fijate que con la MFA activada hay que crear un token en npm tipo 'Automation' para que se salte el MFA.

NOTA: puedo ver que esta libreria crea una release además de llevar el versionamiento y auto-despliegue a NPM.Flipando.

Resumen:configurar package.json,tsconfig.json con lo necesario,instalar rimraf,copy-files,configurar scripts,... una vez todo preparado instalar semantic-release en desarrollo y agregar los plugins al package.json.Crear los tokens programáticos y la Github Action.Volver a esta sección si es necesario.

IMPORTANTE: si no agrego las palabras clave se creará un simple push,y aunque se disparé la acción no entrará semantic-release,asi que no se creará la release ni el deploy.Realmente no tengo porque crear una release ni un deploy siempre.
Fijate que esto es muy conveniente.

					VIDEO 178 ERRORES COMUNES

ERROR UNO: usar CSSModules.
Un error muy común es que al usar CSSModules(file.module.css) el import que usamos no es el correcto(import Module from '' y tiene que ser sólo import 'file.css')

La solución parece que es usar esto en un file llamado 'declarations.d.ts':
declare module '*.css' {  } <- y ya está??

ERROR DOS: no exportar los componentes por defecto.
Simplemente asegurarme que exporto todos los componentes por defecto también.
Esto aumenta la compatibilidad ya que lo pueden importar los consumidores o bien desestructurando o renombrandolo si así lo desean.

Para probar esto en cualquier proyecto puedo instalar este modulo npm y despues traerme el botón y la label:

npm i oscargm40-my-storybook-components

import { MyLabel,Button}  from 'oscargm40-my-storybook-components';
<My Label label="Hola mundo" size="h1">
<Button label="click me" primary />

				SECCION 14 PASAR CALENDAR-APP A PWA

Nuestro objetivo es tener una aplicación de React completa,pero implementando toda la tecnología de PWA a una aplicación de React,mediante ciertas estrategias.

Funcionará sin conexión,hará background-sync...En esta sección sólo la traeremos.

En esta sección tendremos unas instalaciones de una aplicación y backend hechos en mi curso de React de cero a experto, no hace falta que tomen ese curso, pero es una aplicación real de React, con patrón Redux y autenticación por JWT hacia nuestro backend.

El objetivo de la sección es:
1- Tener una aplicación real de React
2- Tener un backend y base de datos
3- Tener una introducción a las PWAs

			VIDEOS 183-184 PREPARACION SECCION Y CAMBIOS EN CALENDAR-APP

Descomprimo sus dos repos y reinstalo dependencias.Ajusto las environment.Fijate que ha introducido pequeños cambios.
Nosotros,con una PWA podemos mantener toda la funcionalidad de una app,a pesar de no tener conexión a internet o tener una conexión a internet limitada.
En esta aplicación podremos realizar peticiones POST,PUT,DELETE y que se terminen de realizar en cuanto tenga conexión.

			VIDEO 185 INTRO A LAS PWA Y SERVICE WORKERS

Una PWA viene del término Proggresive Web Application.No tiene nada que ver con el término 'responsive',puede no ser responsive y sí ser PWA.
Lo que transforma en una PWA a una aplicación es un archivo llamado Service Worker,el cual implementará ciertas configuraciones dependiendo de lo que queramos implementar,es decir que es el archivo de configuración.

Una PWA usualmente está destinada a mejorar la experiencia de usuario.Nos puede ofrecer las siguientes características,dependiendo de lo que configure:

1- Acceso a la aplicación sin conexión
2- Creación de una base de datos local
3- Push Notifications
4- Uso de recursos nativos como la cámara y GPS
5- Sincronización en segundo plano

** La base de datos local funciona como un fallback.Mientras no haya conexión será la opción elegida,para una vez haya conexión realizar cualquier operación almacenada.Usualmentes es una DB temporal por motivos de seguridad

Fijate que el uso de la camara y una DB permite tomar fotografias,por ejemplo,y no perderlas.
La sincronización en segundo plano es una feature increíble que permitirá sincronizar la DB principal remota con la local en segundo plano en cuanto se recupere la conexión.
También se puede usar mensajería,entre otras cosas más.Es un tema muy grande,que aqui solo veremos una pincelada(Fernando tiene un curso de PWAs)

¿Pero cómo funciona una PWA?Cuando un usuario realiza la primera petición el sservidor envia la primera respuesta,con la aplicación a pintar por el browser.Es en esta primera respuesta donde viene algo llamado Service Worker.

El Service Worker va a transformar la forma en que trabajará esa aplicación.Desde ese momento,el Service Worker se pondrá en medio de navegador/servidor,es como un middleware en ambas direcciones.
La aplicación puede pedir algo,interactuar con el Service Worker y no necesitar del backend.
IMPORTANTE: el Service Worker funciona como un proxy en segundo plano.No corre al mismo nivel(segundo error,siempre está en segundo plano).

UN Service Worker pueder realizar estas tareas:
1- Interceptar peticiones
2- Estar pendiente de notificaciones push
3- Corre en segundo plano
4- Manejar el caché de manera manual,permitiendo que no sea el navegador el que administre el caché,y que sea él el que devuelva algo ya cacheado(entre 20-100MB).
La capacidad depende de la implementación que hizo el navegador,dependiendo de cual se esté usando.
Fijate que de nuevo la palabar clave es 'puede'.Es altamente configurable.

IMPORTANTE: La aplicación debe ser servida en protocolo HTTPS.No se puede instalar el Service Worker sin un protocolo https.Pero,ojo,si funciona en desarrollo local usando localhost:<port>.Por último la PWA no puede arrancar con yarn start,para poder probar la PWA hay que usar la aplicación de producción.

Por último PWA no está atado ni a responsiveness ni a SPAs.Funciona con cualquier aplicación Web,y especialmente bien con aplicaciones en base a tokens.

					SECCION 15 REACT + PWA

NOTA:normalmente el Service Worker es algo que se añade despues.Se ven tres problemas principales:
1- comprobar el token:¿como comprobarlo si no tengo conexión al backend?
2- mandar peticiones al backend <- como mandarlas si no tengo conexión?
3- decidir cuando usar el caché local y el remoto.

Esta sección es una introducción técnica a las PWA con aplicaciones de React, recuerden que la PWA no es una tecnología que sólo se aplique a React, pero aquí veremos como integrarlo de varias maneras.

Si pueden, creen un commit / branch en Git para que después puedan regresar rápidamente al proyecto tal cual lo tenemos ahora, ya que después haremos lo mismo y mucho más pero con Workbox.

Esta sección es importante porque explicamos los fundamentos y formas te trabajar con la PWA usando la configuración por defecto que nos ofrece npx create-react-app.Puntualmente veremos:

1- Service Worker
2- Caché
3- Instalación
4- Fetch
5- Estrategias del caché
  a. Network first
  b. Cache Only
  c. Network first with cache fallback

				VIDEO 188 LEVANTAR AMBOS PROCESOS BACK Y FRONT

NOTA: recuerda que una PWA no está atada al backend.

IMPORTANTE: cuando se hace el build de una SPA se generan chunk.js con un hash random al principio.Se le cambia el nombre ya que si no el servidor no sabría que hay un cambio y serviría el archivo anterior,que lo tendrá en caché,no sirviendo el cambio nuevo.
Puedo traducir cachear por almacenar información en el disco duro del cliente.

Dado que el Service Worker no funciona con WDS(Webpack develop Server) no puedo usar yarn start sin más.Fijate que PWA se implementará pues con una aplicación terminada.
Asi que va a haber que instalar 'serve' en global(quizas con live-server también vale).Una vez instalado ejecuto serve -s build:
>serve -s build

		VIDEO 189 SERVICE WORKER PARA UNA APLICACION EXISTENTE

Hay tres formas para pasar una app a PWA.De estas tres,sólo una está ligada a React,las otras dos son agnosticas al framework.Veremos las tres.
Documentación oficial: https://create-react-app.dev/docs/making-a-progressive-web-app/

Como nuestra aplicación ya está creada(que es el 99% de los casos) no habré usado el comando inicial (--template cra-template-pwa).Lo más fácil es crear una app temporal con ese comando y pasar a la app original todo.
>npx create-react-app my-app --template cra-template-pwa
NOTA:Workbox la compró Google y es una forma muy fácil de trabajar con PWAs.Lo veremos en la siguiente sección,pero veré que está por todos lados.

PASO UNO:copio el serviceWorker.js y el serviceWorkerRegistry.js a mi proyecto.
PASO DOS: necesito todas las dependencias(todas las que ponga workbox,son unas diez)OJO,son dependencias normales.
Lo mejor es pegar todo al package.json y ejecutar npm i o yarn.

PASO TRES: arreglar imports(en el index.js)
import * as serviceWorkerRegistration from "./serviceWorkerRegistration"; 
serviceWorkerRegistration.unregister(); <- ojo que es unregister.

PASO CUATRO: cambiar el unregister por register ya que es lo que queremos.
** Si todo esta correcto ahora puedo ejecutar el 'build' de nuevo y debería ver como compilan los archivos anteriores a /build/static/js/service-worker.js.**
Es un archivo minimizado con todo lo necesario.
Puedo ejecutar npm run build cuantas veces quiera.

Sirvo la aplicación y puedo ir en las DevTools a application/ServiceWorker.Veré que esta activado(boton en verde)

		VIDEO 190 ¿QUÉ ESTA SUCEDIENDO CON ESTA IMPLEMENTACIÓN POR DEFECTO?

Realmente apenas copié dos archivos y reinicie la aplicación,pero¿que ha cambiado?Varias cosas:

1- Puedo ir a Application/Cache y veré una cache llamada 'workbox-precache-v2' y otra 'images-http...'.Esto es bueno,ya que ahora hay imagenes cacheadas y otros recursos.Puedo ver que me ha cacheado todos los chunks.js y los .css y el index.
En resumen ,me ha cacheado la aplicación.

IMPORTANTE: Fernando no recomienda usar 'SKIP_WAITING' en una PWA,pues se salta una parte del ciclo de vida del ServiceWorker.
NOTA:esta caché será un espacio nuevo que se cree en la computadora del anfitrión(puede borrarse fácilmente desde esa pestaña,claro)

Fijate que si estos archivos cacheados no cambian no haría falta pedirlos al servidor,no?.Si no han cambiado me valen.

2- Puedo ir a Application/ServiceWorker y darle en offline.Esto quita la conexión.Si ahora recargo veré varias cosas interesantes:
1- veré que no cae la aplicación,no sale el dinosario de Google ni un error
2- incluso veré que está leyendo la CDN para el Boostrap y por ello implementando la fuente Roboto(está accediendo al que tiene cacheado el navegador)
3- puedo ver esta incluso leyendo la app,y haciendo caso a su lógica(de ahi que veo el checking).Claro que esto ahora es un problema,pues necesito pasar de ese checking.

La parte de una PWA se aleja mucho de lo que es crear una aplicación con React,ya que lo que hace es trabajar con una app ya terminada,realmente.

Bien,podemos ver que nuestro primer problema es que estamos tratando de acceder a un endpoint(http:dominio/api/auth/renew) para revisar el token,pero no podemos acceder porque no tenemos conexión a internet.Este es nuestro primer problema que hay que resolver.

Fernando deja un enlace a Workbox.Workbox es una tecnología que compró Google y permite implementar configuraciones estandar rápidamente para Service Workers.

Más adelante veremos esto,pero ahora mismo necesitamos hacer esta configuración manualmente y entender que hizo Workbox por nosotros.Genial.

					VIDEO 191 DESCARGA E INSTALACIÓN DE SW

Para poder pasar del punto en el que estamos hay que entender el ciclo de vida de un Service Worker

Ciclo de vida inicial:la primera vez no habrá un ServiceWorker en el ordenador del usuario,asi que primero se instala el ServiceWorker y despues se activa.En este ciclo de vida se pueden hacer instalaciones en la cache o disco duro.Una vez se activa hace de proxy entre el front y el back(siempre pasa por el SW,aunque haya conexión).

 Partes de ciclo de vida: install, activate,fetch.Las dos primeras ya las he visto,install instala el SW,activate lo activa.La tercera permite tomar el control cuando sucede una petición REST o a una DB.No confundir con la fetch API,cuando sucede una petición externa en PWA es el ciclo de vida fetch(viene de fetchear datos.

Ejemplo de ciclo de vida install que abre un cache llamado 'static-v1' y cachea un gato:

self.addEventListener('install', event => {
  console.log('V1 installing…');
  // cache a cat SVG
  event.waitUntil(
    caches.open('static-v1').then(cache => cache.add('/cat.svg'))
  );
});

Ejemplo de ciclo de vida 'activate' en el que no se hace nada:
self.addEventListener('activate', event => {
  console.log('V1 now ready to handle fetches!');
});


Este ciclo de vida 'fetch' es muy importante.Fijate que puedo saber la url a la que se queria ir con event.request.url:

self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);

  // al ser url de tipo URL puede acceder a origin o pathname
  if (url.origin == location.origin && url.pathname == '/dog.svg') {
    event.respondWith(caches.match('/cat.svg'));
  }
});

Alcance y control: El alcance predeterminado de un SW es ./ Si instalo un SW en example.com/foo/ tendré acceso a foo/*,a todo lo de dentro,pero no al primer nivel de example.com(obviamente tenia que haber instalado el SW en la raiz para esto)

Casi siempre se instala en el mismo nivel que esté la app(normalmente en la raiz,pero depende del dominio)Hay que tener cuidado con el alcance del SW.

NOTA: si bien me puedo saltar la fase de espera entre install y activate con el método self.skipWaiting() Fernando recalca que es importante esperar por si acaso el SW está pidiendo algo o haciendo algo importante.

IMPORTANTE: para acceder al SW tengo que usar self.Vayamos al service-worker.js y creemos la lógica nosotros:

self.addEventListener('install', event => {
  console.log('instalando');
});
 
    			VIDEO 192 FORMA MANUAL - GRABAR EN CACHÉ

Usualmente,cuando se arranca la app querré meter en la caché varios recursos útiles para la app.
IMPORTANTE: yo puedo hacer referencia al disco duro del cliente,creando mi caché customizada con lo que desee:
self.addEventListener('install', async (event) => {
  const cache = await caches.open('mi-caché-v1'):Promise<Cache>;
  await cache.addAll([
    "https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css",
    "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css",
    "/favicon.ico"
  ]);'

		VIDEO 193 REALIZAR FETCH OFFLINE DENTRO DEL SERVICE WORKER

Tal vez esta es la parte que más interesa,junto con las estrategias del caché(hay unas 20 o 30,y dependerá del tipo de aplicación y/o del tipo de peticiones).

Si me fijo en el CDN cacheado para Bootstrap veré que yo nunca voy a cambiar esto.Si dentro de 20 años pidiera este archivo Bootstrap 4.5.0 me devolverían lo mismo,asi que, ¿para que pedirlo?.Esta estrategia se llama caché only

NOTA: si voy a la pestaña Network y recargo veré que el ServiceWorker esta sirviendo ciertos archivos y el disc cache(en mi caso no actua el memory cache,que es el cache del navegador).

Bien,siguiendo con lo nuestro,vamos a ver el ciclo de vida 'fetch'.
self.addEventListener('fetch', (event) => {
  console.log(event.request.url)
});

Puedo ver que se han realizado bastantes peticiones:
http://localhost:3000/manifest.json
http://localhost:3000/favicon.icon
* Y al 5000 para el service-worker.js y obviamente a localhost:4000/api/auth/renew: http://localhost:4000/api/auth/renew

También puedo ver que solicitó la CDN de font-awesome
https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css

IMPORTANTE: realmente no es importante ninguna,sólo es importante ver como el SW está interceptando todas y dejandolas pasar,pues no he configurado nada para él.
Sin embargo ya sé como retornar algo en base a la url de la petición,por ejemplo ya sabriamos hacer algo si se intenta realizar una petición a /api/auth/renew.

Volviendo a las estrategias,podría hacer que el font-awesome y el bootstrap estén con la estrategia 'caché only',y ser servidas siempre desde cache.Obviamente es una buena idea
Y de nuevo fijate como el endpoint domain/api/auth/renew no podría tener esta estrategia 'caché only' ya que valida el token.Lo ideal sería aplicar la estrategia Network First With Cache Fallback,cuyo nombre explica todo.

Si la solicitud a ese endpoint diera un error entraria la caché como fallback,y yo podría almacenar la respuesta anterior a la caida en cache(es decir que cuando se hace la llamada al endpoint se almacena en la cache por si cae internet)
NOTA:Aun faltaría saber si el JWT expiró.Y recuerda que si el usuario hace logout elimina el token

			VIDEO 194 NETWORK FIRST WITH CACHE ONLY PART ONE

El network first with cache fallback es muy útil para este tipo de request,como ésta para verificar el token.Hay muchas estrategias,como cache first with network fallback,que hace lo contrario,mirar en caché y sino ir a internet.
Incluso hay cache first with network fallback with cache update,que primero mirá en caché ,si no esta ahi va a Internet pero además actualiza el caché.
Desde luego es una estrategia muy usada.
 
Puedo filtrar de forma rudimentaria con un if:
self.addEventListener("fetch", async (event) => {
  if (event.request.url !== "http://localhost:4000/api/auth/renew") return;

const resp = fetch(event.request)
  .then(response => response.clone())
  .catch(err => console.log("offline response"));

event.respondWith(resp)

NOTA:fijate que lo primero es clonar la response para romper la referencia y no trabajar sobre ella cual asinto.

* IMPORTANTE: fijate que tengo acceso a la fetch API(incluso podría instalar axios),asi que puedo realizar peticiones perfectamente.Sin embargo esta petición obviamente fallará,pues es justo lo que tengo hasta ahora una petición fallida al /renew por no haber conectividad.Esta petición tal como está es lo mismo,va a fallar

			VIDEO 195 NETWORK FIRST WITH CACHE FALLBACK PARTE DOS

Bien,lo que vamos a hacer es guardar en una cache la response a la request:
const resp = fetch(event.request)
  .then( (response) => {
    caches.open("cache-dynamic")
      .then( cache => cache.put(event.request,response.clone())
  })
  return response.clone()
 .catch( error => {
    return caches.match(event.request);

IMPORTANTE: caches.match busca en todas las caches,obviamente sé que está en la cache 'cache-dynamic' pero muchas veces no sabŕe explicitamente qúe caché es.
Fijate que para escribir en la cache se usa cache.put(key,value) ya que es un Map.Y recuerda que abro una cache cuando quiera con caches.open(<name>).Este caches.open():Promise es una promesa asi que puedo acceder a la caché con .then( cache => ...)
Con todo esto lo que consigo es que la primera vez que haga una peticíon al token el usuario lo almacenaré en la cache y si se cae internet despues,ese fetch(event.request) va a entrar por el catch y devolverá caches.match(event.request) que obviamente es la response que necesito

NOTA: esto lo puedo ver en la pestaña Network y veré que viene del ServiceWorker.Obviamente no consigo hacer fetch de los eventos en el calendario,ya que solo tengo cacheado un posible error para /auth/renew.Desde luego es increible esto.
Es lo siguiente que vamos a hacer pues,mostrar los eventos sin conexión también.

			VIDEO 196 ALMACENAR EN CACHÉ LOS EVENTOS

Recuerda que para almacenarlos el usuario tendrá que haber realizado una petición exitosa al menos una vez.Es exactamente igual que el anterior:
self.addEventListener("fetch", (event) => {
  console.log(event.request.url, "fetch para event");
  if (event.request.url !== apiOfflineFallbacks[1]) return;
  
  const resp = fetch(event.request)
    .then((response) => {
      if (!response) {
        return caches.match(event.request);
      }
      caches.open("cache-events").then((cache) => {
        cache.put(event.request, response.clone());
      });
      return response.clone();
    })
    .catch((error) => {
      return caches.match(event.request);
    });
  event.respondWith(resp);
});

En este punto se presentan nuevos inconvenientes.Si no tengo conexión a internet debería ocultar el boton de agregar evento al calendario,y el de borrarlo cuando tengo activo uno.
Fijate que además ya no son peticiones GET sino POST o DELETE
NOTA: no sólo eso,sino que el endpoint es dinámico:
PUT http://localhost:4000/api/events/61675jf... <- incluso es dinámico el endpoint(el error es ERR_INTERNET_DISCONNECTED)
IMPORTANTE: en el Cache Storage no puedo grabar responses tipo PUT o DELETE.No tiene sentido grabar esos datos.

Usualmente cualquier endpoint diferente de GET recibe un tratamiento diferente.Recuerda que Fernando tiene un curso de PWAs que será bastante bueno.



