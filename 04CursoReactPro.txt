					SECCION 11 FORMIK DYNAMIC Y CUSTOM FORMS

Esta seccion tiene por objetivo construir formularios dinámicos,por ejemplo desde un backend mandando un JSON.Será un archivo pues el que defina el formulario.

Esta sección tomaremos el conocimiento aprendido sobre Formik y crearemos formularios dinámicos basados en data en formato JSON. Aquí aprenderemos:

1- Construir inputs de forma dinámica
2- Construir validaciones basados en propiedades
3- Selects, Inputs
4- Ideas para validaciones

Es una sección corta, pero bastante solicitada, el objetivo principal de la misma es que tengamos la idea de formularios dinámicos y que logremos adaptarlo a nuestras necesidades particulares.

					VIDEO 147 TAREA REGISTER FORM CON FORMIK

Copiamos el register y la tarea es pasar todo a Formik.
NOTA:fijate que el onSubmit puede ser asincrono sin ningun problema:
   onSubmit={ async (values) => await ...}

IMPORTANTE: para hacer referencias a otros controles se usa Yup.ref('fieldName'):
  password2: Yup.string()
    .required("Required")
    .min(6, "Must be 6 characters or more")
    .oneOf([Yup.ref("password1"), null], "Passwords must match"), 

Para resetear ya me dan la funcion handleReset,aunque yo usé la propiedad resetForm:
  <button type="button" onClick={() => formik.resetForm()}>

					VIDEO 148 FORMULARIOS DINÁMICOS

El objetivo de los formularios dinámicos es que realmente sean dinámicos,es decir,que sean creados en tiempo de ejecución,al recibir el json.

Como ese JSON puede lucir de cualquier forma,habrá que crear un standar con las bases.Por ejemplo,un input puede lucir asi:
[
  {
    "type":"input",
    "name":"firstName",
    "placeholder":"Enter First Name",
    "label":"First Name",
    "value":""
  }
]

Ya sólo es traerlo al Javascript.Obviamente faltan los demás campos y en la realidad esto será la repuesta http de un backend...:
import formJson from './../data/custom-form.json';

Realmente iterar sobre este json es muy fácil:
  {(formik) => (
          <Form>
            {formJson.map( (field) => {
              return (
                <MyTextInput
                  key={field.name}
                  type={field.type as any}
                  label={field.label}
                  name={field.name}
                  placeholder={field.placeholder}
                />
              );
            })}
Lo dificil va a ser sacar los initialValues de forma dinámica.

			VIDEO 149 CREANDO EL INITIAL VALUES DE FORMA DINÁMICA

Fijate que al no tener los initialValues tengo el error de que React intenta controlar un componente no controlado.Esto es porque faltan los initialValues.
Si bien fernando usó un ciclo for of con un map sin retornar nada también vale:

const initialValues:{[x:string]:any} = {};

formJson.map( (field) => {
  initialValues[field.name] = field.value;
})
Fijate que especificar que las propiedades van a ser cualquier key de tipo string es muy correcto => { [x:string]: any } <- any porque pueden ser numeros o booleans

Bien,ahora que sabemos cargar los initialValues dinámicamente falta ver como cargar un <select> u otro tipo de control:

				VIDEO 150 CARGAR SELECTS DE MANERA DINÁMICA

EL JSON para el select va a ser un poco diferente,ya que tendrá un campo options y no lleva placeholder,claro:
  {
    "type": "select",
    "name": "favoriteGame",
    "label": "Favorite Game",
    "value": "",
    "options": ["League of Legends", "Fortnite", "Overwatch", "Dota 2"]
  }
NOTA:fijate que input type="input" crea un input type="text".Esto nos vino genial.Es importante entender que lo importante sería estandarizar la entrada por JSON,obviamente debe ser la misma.

En este punto ya no puedo devolver otro input,debo determinar el tipo de control primero:
   {formJson.map( (field) => { return ( <MyTextInput <- necesito saber el tipo

Fijate que nunca deberia ver este span:
 return <span>Type: {type} no es soportado</span>

Al final es igual de sencillo que los demás:
   if (type === "select") {
    return (
      <MySelect key={name} name={name} label={label}>
        {options?.map((option) => (
    <option key={option.id} value={option.label}>
      {option.label}
    </option>
        ))}
      </MySelect>

Por último,necesitamos las validaciones dinámicas también.En este punto podria usar validate o validationSchema con Yup.

				VIDEO 151 VALIDACIONES DINÁMICAS

Obviamente,solo se trata de añadir un campo más,aunque será un arreglo de objetos,pues puede haber muchas validaciones:

  {
    "type": "input",
    "name": "firstName",
    "placeholder": "Enter First Name",
    "label": "First Name",
    "value": "Fernando",
    "validations": [
      {
        "type": "required",
        "message": "First Name is required"
      }
    ]
  },

Ahora viene lo dificil que es automatizar esto:

const initialValues: { [x: string]: any } = {};

const requiredFields: { [x: string]: any } = {} as unknown as any; 

formJson.map((field) => {
  initialValues[field.name] = field.value;
  
  let schema = Yup.string();

  if (field.validations !== undefined) {
    for(let rule of field.validations) {
      if(rule.type ==="required"){
        schema = schema.required(rule.message);
      }else if (rule.type === "minLength") {
        schema = schema.min((rule as any).value || 1, rule.message);
      } else if (rule.type === "email") {
        schema = schema.email(rule.message);
      }

    }

    requiredFields[field.name] = schema;
  }

});

const validationSchema = Yup.object().shape({...requiredFields});

Puedo observar que quitando un par de zonas dificiles es bastante sencillo crear formularios dinámicos y,desde luego,parece bastante útil.

Claro que aun faltan muchas cosas,de momento queda asi.Crear nueva rama y dejarla como 'dynamic-forms'.

SECCION 12 STORYBOOK-CAMA PARA CREACIÓN Y MANTENIMIENTO DE COMPONENTES Y PAQUETES

Puedo imaginar STORYBOOK como una mesa de construcción,en la cual puedo construir componentes.Empieza como una aplicación de React,pero no termina siendo eso,
sino que es una zona para construir componentes.
No sólo eso,sino que puedo jugar con esos componentes,mandarles propiedades,generar documentación automatica,compartir los componentes mediantes enlaces http.

Esta sección está enfocada en aprender como integrar Storybook en nuestras aplicaciones de React para transformarla en una aplicación que nos ayudará a probar y desarrollar de una mejor manera nuestros componentes.

La sección tiene por objectivo aprender:

1- Integrar Storybook en una aplicación de React con Npx
2- Crear un componente desde cero
3- Crear historias
4- Configurar historias
5- Utilizar varios controles para las properties
6- Integración con TypeScript
7- Crear documentaciones de componentes
8- Desplegar documentación a diferentes sitios
9- Bonus: Chromatic para desplegar Storybook de forma colaborativa

				VIDEO 156 INICIO PROYECTO - MY STORYBOOK -

IMPORTANTE: Storybook(https://storybook.js.org/) no es algo que esté ligado a un framework en concreto.Puedo usar React,Angular,HMTL,Vue,Ember,...

Lo primero que hay que hacer es crear una aplicación de React(investigar Vite y NextJS):
npx create-react-app <name> --template=typescript

NOTA: con storybook se trata de crear componentes,no aplicaciones,para despues compartirlos o guardarlos.

			VIDEO 157 INSTALAR Y CONFIGURAR STORY-BOOK EN LA APP

Para añadir storybook debo ejecutar npx sb init(no admite un proyecto vacio):
>npx sb init
NOTA:el comando vale para todos los frameworks.
Esto crerá ciertos componentes de demostración,asi como la cama para manejarlos,etc.Pero antes de ejecutarlo primero hay que limpiar varios archivos y directorios:

NOTA: podriamos haber usado npm eject,pero crea muchos archivos
UNO: Primero ejecuto esto
npm remove react-scripts
DOS: Despues borro todo(carpeta public y todos los files menos el src/index.tsx(seguir video)
TRES:ahora si,ya puedo ejecutar npx sb init(tarda un rato)
* puedo ver que puedo ejecutar npm run storybook

CUATRO: antes de ejecutarlo repasemos los cambios.TEngo una nueva carpeta '.storybook' con dos files main.js y preview.js.Son archivos de configuración para agregar addons,plugins,etc para storybook.

También creó un folder 'stories' con varios componentes(cada uno formado por button.css,Button.stories.tsx y Button.tsx).Es decir el componente,sus estilos y un archivo .stories.tsx

CINCO:puedo ver dos nuevos scripts en el package.json:
  "storybook": "start-storybook -p 6006",
  "build-storybook": "build-storybook"
Obviamente,uno es para hacer el build y otro para correr la aplicación(levanta storybook en ese puerto).
IMPORTANTE:los comandos con react-scripts ya no me valen asi que puedo dejar estos dos,o renombrarlos,etc..

Por último limpio el index.ts ya que tampoco tengo el index.html y no me vale ese código.Ejecuto npm run start | storybook y debería abrirse su interfaz web.

			VIDEO 158 MODULOS DE CSS Y LEVANTAR STORYBOOK

Fijate que Fernando tenia problemas al levantar la app.Le pedia instalar postcss,entre otras cosas(parece que ya lo corrigieron).
Fernando deja un gist con esto:
gist: https://gist.github.com/Klerith/c82cbe0c4733184deaddf3421e8acff5

PASO UNO 
yarn add -D @storybook/addon-postcss postcss css-loader

PASO DOS: en el .storybook.main.js:
module.exports = {
  addons: [
   {
    name: '@storybook/addon-postcss',
    options: {
      postcssLoaderOptions: {
        implementation: require('postcss'),
      },
    },
  },
  
  ]
}
PASO TRES: crear el postcss.config.js:
module.exports = {
  // Add your installed PostCSS plugins here:
  plugins: [
    // require('autoprefixer'),
    // require('postcss-color-rebeccapurple'),
  ],
};

IMPORTANTE: tras levanta exitosamente storybook puedo ver el contenido del  componente Introduction.stories.mdx por pantalla.Esta extensión es MarkDown + XML
Este lenguaje MDX juntará MarkDown junto a tags xml(<></>).

Bien,en la interfaz puedo cambiar todas las props que se definan en código,en este caso,tres tamaños,el color,el texto de la label y poco más.

NOTA:los comentarios también se reflejan en la interfaz web,asi que puedo y debería documentar el componente:

interface ButtonProps {
  /**
   * Is this the principal call to action on the page?
   */
  primary?: boolean;

					VIDEO 159 COMPONENTE MY-LABEL

Recuerda que esta app está creada para crear y testear este tipo de componentes,despues subirlos a GitHub y/o desplegarlos a Npm.

IMPORTANTE: Button sería una story y Primary como una página.Asi que minimo necesito una story con su primera página:

import MyLabel from '../../components/MyLabel';

export default {
  title: 'YourComponent',
  component: MyLabel,
};

const Template = () => <MyLabel />;

export const Basic = Template.bind({});
export const AllCaps = Template.bind({});

IMPORTANTE: Template.bind({}) rompe la referencia.Esto es necesario ya que en JS todo va por referencia.Es la única forma de que sean componentes diferentes.

En cuanto a la jerarquia de archivos todo depende del title:
export default {
  title: 'UI/Etiquetas/MyLabel',
  component: MyLabel,
};
Esto meterá las páginas en UI/Etiquetas/MyLabel/... lo cual tiene más sentido que el Example/Button que me dan.

		VIDEO 160 AÑADIR PROPS Y CONTROLES A NUESTRA HISTORIA Y COMPONENTE

Añadir props realmente no es nada que no sepa ya:

interface LabelProps {
  label: string;
  size: "normal" | "h1" | "h2" | "h3";
}

const MyLabel = ({ label = "No Label", size = "normal" }: LabelProps) => {
  return <span className={`label ${size}`}>{label}</span>;
};

Sin embargo,esto va a obligar a usar las clases ComponentMeta<T> y ComponentStory<T> de esta forma:

export default {
  title: 'UI/Etiquetas/MyLabel',
  component: MyLabel,
} as ComponentMeta<typeof MyLabel>

const Template: ComponentStory<typeof MyLabel> = (args) => <MyLabel {...args}/>;

Ahora ya no veré el error de TS sobre los args.Y si voy a la interfaz ya puedo elegir el font-size de entre los que he estilizado y establecer el texto de la label dinámicamente.

Sin embargo,puedo ver que faltan muchas cosas,como que venga con valores por defecto.Esto lo lograŕe tras romper la referencia al componente con Template.bind({})  ya que por ejemplo la label AllCaps debería estar en mayúsculas :

export const Basic = Template.bind({});
Basic.args = {
  label: 'Basic',
  size: 'normal',
}

export const AllCaps = Template.bind({});
AllCaps.args = {
  label: 'ALL CAPS',
  size: 'normal',
}
	
			VIDEO 161 DOCUMENTAR AUTOMÁTICAMENTE LAS DESCRIPCIONES

Todavia faltaría crear un documentación.Ya hemos visto como se hacia.Fijate que una buena documentación será fundamental.

IMPORTANTE: para storybook un comentario es insignificante asi que no va a re-buildear todo.Para ver los cambios tendré que cambiar algo del código o reiniciar el server.

			VIDEO 162 TAREA PROPIEDADES Y CONTROLES ADICIONALES

Realmente no tiene mucho,todo depende de lo que quiera,estilizarlo:

export const Basic = Template.bind({});
Basic.args = {
  size: 'normal',
  allCaps: false,
  color: 'primary'
}

export const AllCaps = Template.bind({});
AllCaps.args = {
  label: 'ALL CAPS',
  size: 'normal',
  allCaps: true,
  color: 'primary'
}

export const Secondary = Template.bind({});
Secondary.args = {
  label: 'Secondary',
  size: 'normal',
  color: 'secondary'
}

export const Tertiary = Template.bind({});
Tertiary.args = {
  label: 'Tertiary',
  size: 'normal',
  color: 'tertiary'
}

const MyLabel = ({
  label = "No Label",
  size = "normal",
  color = "primary",
  allCaps = false,
}: LabelProps) => {
  return (
    <span
      className={`label ${size} text-${color} ${allCaps ? "uppercase" : ""}`}
    >
      {label}
    </span>
  );

IMPORTANTE: no es buena idea dejar todo como sale por la interfaz web,ya que saca siempre <input type="checkbox">.Esto obviamente no es siempre lo que querré.
Storybook trata de hacer lo mejor posible,si el campo es un boleano pone un selector de true,false pero siempre puedo usar el selector que yo quiera con la propiedad argTypes:

				VIDEO 163 NUEVA PROPIEDAD - COLOR DE FUENTE

Es una tarea en la que meter un <input type="color">.Realmente es muy sencillo,simplemente le paso ese argTypes:

  fontColor: { control: 'color' }
Y la nueva página será un h1
export const CustomFontColor = Template.bind({});
Tertiary.args = {
  label: 'Custom Font Color',
  size: 'h1',
  fontColor: 'tertiary'
}

Lo más fácil es usar un estilo en línea:
 style={{ color: fontColor }}

				VIDEO 164 DESPLEGAR STORYBOOK A SERVIDORES

Digamos que ya tengo listo el componente y lo quiero subir a la Cloud.También veré como aprobar o cancelar cambios de manera colaborativa en Storybook.

						PASOS A SEGUIR

UNO: hacer el build(comando build-storybook).Esto crea la carpeta storybook-static.Esta es la carpeta importante.
Puedo hacer una prueba con la libreria http-server(npm i -g http-server)
live-server storybook-static --port=3000(usaré live-server)

DOS: desplegarlo(puedo arrastar esa carpeta en Netlify,por ejemplo).

Como puedo observar no puede ser más fácil desplegar un componente con storybook(fijate que creó un index.html)

				VIDEO 165 GITHUB Y GITHUB PAGES

Este despliegue no es opcional ya que en la siguiente ección vamos a ver despliegues automáticos con GitHubActions.
Asi pues creo un repo,se recomienda que sea público para aceptar PRs

NOTA: no debo subir esta carpeta asi que tengo que ignorarla.No tiene sentido subirla ya que se va a generar mediante un despliegue automático:
/storybook-static

Lo que si que hago es cambiarle el nombre de la carpeta a docs asi ya puedo configurar GitHub Pages.

					VIDEO 166 BONUS: CHROMATIC 

La integración de Storybook con Chromatic es muy buena.Es una herramienta colaborativa .Bien,hago el signup con GitHub y eligo entre crear nuevo proyecto o elegirlo desde GitHub.
Eligo el repo recién creado.

PASOS PARA USAR CHROMATIC EN UN PROYECTO
UNO:habrá que instalar en modo dev el paquete chromatic en el proyecto:
npm i -D chromatic

DOS: publicar el storybook mediante chromatic con el token único que tiene cada proyecto:
npx chromatic --project-token=8801b679c19d

Debería de haber podido publicar una Storybook con Chromatic

			VIDEO 167 CHROMATIC - ATRAPAR CAMBIOS EN LA UI

Vamos a hacer algun cambio en nuestro storybook para analizar que sucede en Chromatic.Levanto storybook en local y realizo algun cambio,por ejemplo un custom color para el background:

export const CustomBackgroundColor = Template.bind({});
CustomBackgroundColor.args = {
  label: "Custom Font Color",
  size: "h1",
  fontColor: "#5517ac",
  backgroundColor: "#000"
};

Una vez vea en local que está todo correcto puedo hacer el re-deploy a chromatic con el mismo comando(npm run chromatic).Hay que hacer el push a GitHub antes.

Bien,esto creará un segundo Build en chromatic(fijate que puedo invitar a teammates).Voy a ese segundo Build y debo revisarlo(review changes).Fijate que puedo crear usuarios y roles en chromatic.
Veré los cambios y puedo agregar marcadores con texto,muy útil,ya que podrá crear un marcador cualquier colaborador.
Esto es sólo una pincelada de Chromatic,parece una buena librería colaborativa para usar con storybook,aunque parece que hay que pagar por las features mas interesantes.

SECCION 13 GITHUB ACTIONS+SEMANTING VERSIONING+AUTOMATING NPM DEPLOY+STORYBOOK

Esta sección tiene por objetivo automatizar este workflow,de forma que con un sólo push o un PR se recorra todo el workflow:

Subir a Github los cambios
Crear release-semántico
Transferir esta release a npm (npm publish)

Esta sección es genial, aprenderemos lo siguiente:
1- Tomar nuestros componentes probados con Storybook
2- Generar los archivos de definición de TypeScript
3- Generar el build de producción
4- Crear una acción en Github actions para crear el versionamiento semántico
5- Usar el versionamiento semantico para publicar la version del paquete
6- Publicar el paquete en NPM
7- Actualizar paquete
8- Consumir el paquete en aplicaciones externas.

			VIDEO 171 CONTINUACION DE LA SECCION - EDITING PACKAGE.JSON

Bien,recuerda que tengo que poner private a false para desplegar un proyecto.

IMPORTANTE: a la hora de desplegar un paquete es buena idea que me tome algo de tiempo y dejar todo correcto.La propiedad typings indicará los archivos de definición de tipos,main el punto de entrada,homepage o repository son metadata muy importante y license,private,versión,...todo es importante.

Seguiré con la propiedad release que apunta a un arreglo de ramas y files que apunta a un arreglo de directorios o archivos(ambos se admiten).Fijate:
  "release":{
    "branches":["master"]
  },
  "files":[
    "dist",
    "src"
    "package.json"
    "README.md"
  ],

Esto es la base de casi cualquier deploy,pero a nosotros aún nos faltan ciertas configuraciones por estar usando TypeScript.

			VIDEO 172 TSCONFIG.JSON - CONFIGURACIONES PARA TYPESCRIPT

IMPORTANTE: debo tener typescript de manera global.Puedo saber si lo tengo tratando de sacar la version del compilador(tsc --version).Instalar en global con :
npm i -g typescript ó yarn global add typescript

Bien,hay varias propiedades a configurar o añadir:
"outDir":"dist"
"declaration":true <- fijate que ésta es vital,ya que genera los d.ts
"noEmit:false <- estaba en true,mientras esté en true no emite archivos
 
 "include": [
    "src"
  ]
} <- debo asegurarme que está la propiedad incluce haciendo pinpoint correctly

Bien,hacemos el compilado con 'tsc' y vemos que hay algunos errores por no haber exportado las interfaces ni nosotros ni los de storybook.

IMPORTANTE: recuerda que ni el CSS ni las imagenes se van a mover solas.TSc sólo va a transpilar el TS a JS,nada más.Aún queda este trabajo por hacer.

		VIDEO LIMPIAR-COPIAR ARCHIVOS NECESARIOS AL FOLDER DIST

Vamos a usar dos librerias bastante usadaspara remover carpetas y copiarlas.Son 'rimraf'(para borrar directorios y su contenido) y 'copyfiles'(para copiar archivos masivamente).
Fijate que no puedo limpiar con rm -rf pues otro usuario podría estar en Windows o Mac,no puedo usar comandos nativos del SO:

yarn add -D rimraf copyfiles

Creo el script "clean" que eliminará la carpeta
"clean":"rimraf dist/"
Y lo llamo en el script "build",que hará todo en un único comando:
"build":"yarn clean
Bien,lo siguiente es copiar los .css:
"copy-files":"copyfiles --up 1 src/**/*.css dist/"
Lo agrego al comando main:
"build":"yarn clean && tsc && yarn copy-files"

Perfecto.Puedo ver que copió los css al lugar adecuado,respetando su ubicación orginal.

IMPORTANTE: un paso que se dejó Fernando es definir las peerDependencies,que son dependencias necesarias en el equipo para ejecutar este proyecto.En este caso pedimos simplemente cualquier version de React mayor a 16.8 y typescript v4+:

  "peerDependencies": {
    "react": ">=16.8.0",
    "typescript": ">=4.0.0"
  },

				VIDEO 174 SEMANTIC VERSIONING AUTOMÁTICO

El manejo manual del versionamiento semántico es una de las cosas más molestas qeu suele haber.
NOTA:viendo el proyecto de Stephen veo que puedo usar "typings" o "types" como propiedad para los d types( "types": "./build/index.d.ts",)También observo que usó una licencia ISC(  "license": "ISC",) en vez de MIT.
El comando npm version <update_type> aumenta el numero de version(patch | major | minor) en base al type que le pase(npm version patch irá 1.0.1,1.0.2,1.0.3...)

En este punto Fernando sugiere usar la libreria npm 'semantic-release' y además agregarle ciertos plugins para expandir funcionalidades:
>npm i -D semantic-release o yarn add semantic-release -D

Usar estos plugins para trabajar con Semantic Versioning(ya vienen instalados en el paquete anterior):
En el package.json agregar la propiedad "plugins" con:

"plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    "@semantic-release/github",
    "@semantic-release/npm",
    "@semantic-release/git"
],

NOTA: fijate que instalar este paquete en desarrollo no influirá en nada en el paquete que se instalará el usuario de esta librería.Lo que si que se instalará son todas las dependencias normales al instalar esta libreria custom.

En teoría ya está instalado,y fijate que la carpeta dist la debo subir,no puede estar ignorada.Bien,esta libreria trabaja en base a palabras clave que haya en el commit,por ejemplo:
git commit -m "feat: agregado semantic-versioning" <- esto subirá a 1.1.0
