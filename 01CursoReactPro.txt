		CURSO UDEMY REACT PRO LLEVA TUS BASES AL SIGUIENTE NIVEL

Fijate en las nuevas extensiones sugeridas por Fernando:
cssmodules ayuda con los className={styles.class}
mdx ayuda a ver mejor un markdownx(MDX es como JSX,pero para MD,es decir es markdown junto con React.

					SECCION 02 REFORZAMIENTO SOBRE REACT

En esta sección aprenderemos:

1- TypeScript con los principales Hooks de React
2- Pequeñas animaciones con GreenSock
3- Timelines
4- Custom Hooks
5- Referencias a elementos del DOM
6- Objetos como estado
7- Interfaces
8- Types
9- Reducers
10- Actions Creators

Es una sección de reforzamiento en la cual la mayoría de los conceptos deberían de ser familiares a nosotros.

						VIDEO 10 PRIMER COMPONENT

De momento Fernando simplemente crea un Contador al que se le pasa por props el intialValue,forzando a crear la interfaz para el tipado.

NOTA:con la extensión Toggle Quotes puedo cambiar el tipo de comillas.
Para evitar esos ./../../../Input podemos agregar en el tsconfig.json la siguiente propiedad.
{
  "compilerOptions": {
    ...
    "baseUrl": "src",
    ...
} <- pues eso

								VIDEO 11 PROPTYPES

Es muy conveniente trabajar con PropTypes cuando estoy en Javascript.Los proptypes son revisados en tiempo de ejecución.Si bien en JS es muy necesario al usar TS no es necesario.
Con TS puedo usar una interface o type la cual no va a llegar al bundle final de la app y conseguir el mismo efecto(fijate aqui que las PropTypes si que ocuparán espacio si las uso).

type Props = {
  initialValue?: number;
}

const Counter = ({initialValue}:Props) => {

  const [ counter, setCounter ] = useState<number>(initialValue!);

IMPORTANTE: si una prop considero que es opcional debo usar initialValue?:number; al declararla en la interfaz.Si la quiero obligatoria le quito la ?.
NOTA:obviamente hay más formas de hacer esto:

import { useState, FC } from 'react';
 
interface CounterProps {
    value: number
}
 
export const Counter: FC<CounterProps> = ( { value } ) => {

NOTA: la única diferencia actualmente entre type e interface es que luego de creado puedes cambiar la interface o añadir prioridades, mientras que esto no se puede con type.

					VIDEO 12 MANEJAR UN OBJETO COMO ESTADO

  const handleClick = (value: number) =>{
    setCounter({
      counter: counter.counter + value,
      clicks: counter.clicks + 1
    });
  }
Recuerda que es una arrow function y que puedo hacerlo accediendo al previous.

					VIDEO 13 OPTIMIZACIONES Y TIPADO

Realmente Fernando aún no ha tipado el state.Esto es algo que debo hacer en cada useState<T>:

type Counter = {
  counter: number;
  clicks: number;
}

const CounterBy: FC<Props> = ({ initialValue }: Props) => {
  
  const [counter, setCounter] = useState<Counter>({

NOTA:useState<T> realmente siempre fue un genérico,sólo que en JS no importa.

				VIDEO 14 USEEFFECT - COUNTER EFFECT

NOTA:fijate que puedo imprimir con formato usando '%c' para inferir CSS:
console.log("%cESto es un string con estilos","color:red;background:black").
Como segundo argumento lleva una regla CSS.

				VIDEO 15 PEQUEÑA ANIMACION Y USE-REF

Para realizar una pequeña animación de rebote vamos a usar la libreria gsap de GreenSock(https://greensock.com/gsap/)

En la última versión 3 han simplificado su uso agrupando todo en un único paquete.En Docs/Installation tengo varias formas de instalarlo.Usaremos NPM aunque mediante la CDN también es una buena opción:
>npm install gsap (que sea la versión 3 npm i gsap@^3)

Para usarlo me traigo el objeto gsap:
import { gsap } from "gsap";

Y uso su método to(SelectorCSS,{animaciones})
Como SelectorCSS podria usar querySelector,getDocumentById,una simple clase CSS,en resumen cualquier selector.
El segundo argumento es un objeto con las animaciones que quiero
gsap.to(".class", {x:100}) <- moverá 100px al HTML con la clase 'class'.

Con todo esto meto dentro del if del efecto una animacion para que suba 10px y luego los baje:
  useEffect(() => {
    if (counter >= MAXIMUM_COUNT) {
      console.log(
        "%cSe llegó al valor máximo",
        "color: red;background: yellow;"
      );
      gsap
       .to("h2", { y:-10, duration: 0.2, ease:'ease.out' })
       .then(_=> gsap.to("h2",
        { y:0, duration: 0.2, ease:'bounce.out' }));
      }
Fijate que gsap.to:Promise devuelve una promesa con lo que puedo encadenar animaciones.
NOTA:en React no se recomienda apuntar con un selector de etiqueta(h2) ni siquierq mediante una clase(go.to('h2')).Esto lo veremos en el siguiente video de repaso

						VIDEO 16 USE-REF Y TIMELINES

Vamos a arreglar la forma de apuntar con gsap.to(),ya que no es recomendable usar ni selectores de etiqueta ni clases ya que podría haber otro elemento con la misma clase fácilmente sin que me dé cuenta.

Adicionalmente GreenSock no recomienda usar las animaciones tal como hemos hecho,sino usando un timeline(lo que tienen los videos de Youtube).Asi puedo saber en que punto está la animación.

IMPORTANTE:Cuando use referencias con useRef<T> en Typescript tengo que inicializarlas a null,por que si no cogerá undefined y no puedo trabajar con undefined:

// <div> reference type
const divRef = React.useRef<HTMLDivElement>(null);

// <button> reference type
const buttonRef = React.useRef<HTMLButtonElement>(null);

// <br /> reference type
const brRef = React.useRef<HTMLBRElement>(null);

// <a> reference type
const linkRef = React.useRef<HTMLLinkElement>(null);

Recuerda además pasarle el genérico(useRef<T>)

Ya sólo hay que apuntar a la ref.current     
  gsap
   .to(counterElement.current, { y:-10, duration: 0.2, ease:'ease.out' })
   .then(_=> gsap.to(counterElement.current,
        { y:0, duration: 0.4, ease:'bounce.out' }));

IMPORTANTE:fijate que cuando use useRef no importa que no sepa el T.El error me va a decir el T del useRef<T>.

Type 'MutableRefObject<HTMLHeadingElement | undefined>' is not assignable to type 'LegacyRef<HTMLHeadingElement> | undefined'. <- puedo sacar el <T> del error inicial.

NOTA:cuando quiera apuntar a la referencia tengo que apuntar a .current.ESto es asi porque tomando const counterRef=useRef<T>(null) en counterRef sólo tengo el objeto que crea React,pero la referencia a lo que yo quiero está en la propiedad .current de ese objeto que se crea.

IMPORTANTE:dado que en este ejemplo yo estoy tratando con un h2,que es HTML,debería usar useLayoutEffect y asegurarme asi que se carga el DOM(useEffect se dispara en cuanto puede,useLayoutEffect se dispará siempre despues que se cree todo el DOM,asegurandome que existirá ese h2).

IMPORTANTE: dado que se recomienda usar un timeline al usar gsap lo creamos con el método timeline del objeto gsap:
const timeline = gsap.timeline()
El timeline es básicamente un controlador del tiempo. 
      timeline
        .to(counterElement.current, 
        { y:-10, duration: 0.2, ease:'ease.out' })
        .to(counterElement.current,
          { y:0, duration: 1, ease:'bounce.out' });

Puedo encadenar el metodo to,aunque también tiene from,play,pause,repeat.Incluso no hace falta encadenarlos,pues al ser una timeline van a ir en secuencia:
timeline.to(_,__) <- va a ir la primera
timeline.to(_,__) <- va a esperar e ir la segunda,pues es una timeline
Ellas mismas se van a poner en cola pues es una timeline.

		VIDEO 17 CUSTOM HOOKS CON REFERENCIAS A HTML QUE AUN NO HA SIDO CREADO

Recuerda que la convención en React es que un hook empiece con use,da igual que sea mío que de ellos.

export const useCounter = (initialValue: number) => {
  
  const [counter, setCounter] = useState<number>(initialValue);
  const counterElement = useRef<HTMLHeadingElement>(null);
  
  /* functions */
  const handleClick = (value: number) => {
    setCounter((counter) =>
      counter + value >= MAXIMUM_COUNT ? MAXIMUM_COUNT : counter + value
    );
  };

  useLayoutEffect(() => {
    if (counter >= MAXIMUM_COUNT) {
      console.log(
        "%cSe llegó al valor máximo",
        "color: red;background: yellow;"
      );

      const timeline = gsap.timeline();

      timeline
        .to(counterElement.current, { y: -10, duration: 0.2, ease: "ease.out" })
        .to(counterElement.current, { y: 0, duration: 1, ease: "bounce.out" });
    }

    return () => {};
  }, [counter, MAXIMUM_COUNT]);

  return { 
    counter,
    counterElement,
    handleClick
  }

Recuerda que simplemente tengo que devolver algo y usar useName.No puede ser más fácil,asinto.
Sin embargo,simplemente he refactorizado,cualquier error que tuviera lo sigo arrastrando,como que se cree una nueva instancia cada vez que el contador llegue a 10:
   const timeline = gsap.timeline(); <- cada vez que salte el if crea un object.

Sería interesante elevar esa creación de la instancia y no hacerlo en el useEffect.Lo veremos en la siguiente clase.

				VIDEO 18 PARAMETRIZAR Y PULIR NUESTRO HOOK

No hay mucha ciencia detrás para parametrizar un customHook.Simplemente le paso los argumentos que quiera:

export const useCounter = (initialValue: number,MAXIMUM_COUNT:number=10)
Fijate que puedo iniciar uno para hacerlo opcional(incluso puedo crear una interfaz para tipar los args).

IMPORTANTE: useRef permite guardar cualquier cosa,perfectamente puedo guardar la instancia que no queremos volver a crear repetidamente.Simplemente llevará la ejecución del método como argumento del useRef.
const timeline = useRef(gsap.timeline());
Fijate que hasta ahora casi siempre lo inicias en null,pero puedo iniciarlo con lo que quiera,cualquier ejecución de un método,un constructor,lo que sea.Terriblemente interesante,asinto.
NOTA:fijate que podria pasar la ref al <h1> o al botón,pero cambiando el useRef<T>
NOTA:el equipo de React sugiere que cada uno de los useEffect tenga una responsabilidad única,no hay problema en que yo tenga múltiples useEffects:

Por último, y pensando en reusar la animabilidad cambiamos el nombre y tipo:
  const elementToAnimate = useRef<any>(null);

							VIDEO 19 USE-REDUCER

 El useReducer se usa para lo mismo que el useState,sólo que normalmente se usa cuando el estado es un poco más complejo y/o cuando hay cambios que afectan a varias cosas de manera simultánea.

Para implementar el hook useReducer necesitaré un initialState y una función pura reductora.A cambio se me devolverá el interaccionador con las acciones o dispatch y el estado:
 const [state, dispatch] = useReducer(counterReducer, INITIAL_STATE);


Fijate que en TS debería crear una interface para tipar el initialState.Y fijate en este estado inicial que guarda el estado anterior:

interface CounterState {
  counter: number;
  previous: number;
  changes: number;
}

const INITIAL_STATE:CounterState = {
    counter: 0,
    previous: 0,
    changes: 0,
}

Guardar el previous state es algo muy común cuando se quiere dejar al usuario la posibilidad de volver al estado anterior.

				VIDEO 20 FUNCION PURA - XXXREDUCER

Fijate que en la actualidad esta aproximación para tipar todas las posibles acciones es de lo mejorcito:

type Action = 
  | { type: 'increaseBy', payload: {value: number}}
  | { type: 'decrementBy', payload: {value: number}}
  | { type: 'reset' } 

Recuerda que una función pura reductora es una función pura que toma dos argumentos,el estado anterior y la acción y devuelve el nuevo estado:

const counterReducer = (state:CounterState, action:Action) => {
  switch (action.type) {
    case 'increaseBy':
      return {
        ...state,
        counter: state.counter + action.payload.value,
        previous: state.counter,
        changes: state.changes + 1,
      }
    case 'decrementBy':
      return {
        ...state,
        counter: state.counter - action.payload.value,
        previous: state.counter,
        changes: state.changes + 1,
      }
    case 'reset':
      return {
        ...state,
        counter: 0,
        previous: 0,
        changes: 0,
      }
    default:
      return state;
  }
}
Disparo las acciones que quiere Fernando,etc:
  
const handleIncrease = (value:number) => {
    dispatch({ type: 'increaseBy', payload: {value} });
  }

const handleDecrease = (value:number) => {
   dispatch({ type: 'decrementBy', payload: {value} });
  }
De nuevo es buena idea dejar el useState para cosas simples y usar un reducer en cuanto vea que es necesario.

				VIDEO 22 SEPARAR ACCIONES,INTERFACES Y REDUCER

En este punto tenemos todo en un mismo archivo,esto es una mala práctica.
Debería de refactorizar siguiendo a Angular,creando un folder a especie de módulo.En este folder puedo crear las carpetas actions,interfaces y reducer y archivos con extensión .ts(pues no usan JSX).Realmente es sencillo en este punto.

En el siguiente video veré los ActionsCreators o creadores de acciones.Estos generadores nacieron porque si yo ahora quisiera hacer un cambio muy sutil(como cambiar increaseBy por increaseByNumber) tendré que cambiar cosas en varios archivos(en el actions.ts,en el reducer,en cada dispatch...).
Sería mejor tener centralizada la creación de acciones.
NOTA:todo esto se refiere a que no debo escribir los nombres de las acciones en duro:   dispatch({ type: 'increaseBy').Obviamente,es mejor inferir ese valor desde otro archivo.

						VIDEO 23 ACTION CREATORS

Doc: https://read.reduxbook.com/markdown/part1/04-action-creators.html
Es momento de cambiar como estoy infiriendo los tipos de las acciones,y no hacerlo directamente.

IMPORTANTE: una actionCreator es una función pura.Este concepto de implementar las actions types mediante action Creators viene sugerido desde el patrón redux

NOTA:usualmente se acostumbra a anteponerle 'do' a estas actionCreators.

Con todo esto en mente creo las funciones actionCreators que tienen que devolver un objeto de tipo Action.Si llevan payload lo recibirań por argumento:

export const doReset = ():Action => ({
    type: 'reset',
})

export const doIncreaseBy = (value: number):Action => ({
    type: 'increaseBy',
    payload: { value },
})
* Fijate que la doc oficial no retorna un objeto directamente con ({}):
export const doIncreaseBy = (value:number):Action => {
  return { ... } } .
Es en el return donde lo devuelve,pero puedo acortar ese código.

Lo bueno de todo esto es que ahora el dispatch llamará a estas actionCreators de una forma muy sencilla:

Cambiar esto: 
 const handleIncrease = (value:number) => {
    dispatch({ type: 'increaseBy', payload: {value} });
  }
por:
  const handleIncrease = (value:number) => {
    dispatch(doIncreaseBy(value));
  }

Queda mucho más limpio:
  const handleIncrease = (value:number) => {
    dispatch(doIncreaseBy(value));
  }

Todo esto se debe acompañar con una enum o un Map para no introducir los strings en duro:

export enum ActionsTypes {
  INCREASE_BY = 'increaseBy',
  DECREMENT_BY = 'decrementBy',
  RESET = 'reset',
}
export type Action =
  | { type:ActionsTypes.INCREASE_BY,payload:{ value: number } }
  | { type:ActionsTypes.DECREMENT_BY,payload:{ value: number } }
  | { type: ActionsTypes.RESET }  

IMPORTANTE. cuando tengo muchas importaciones de esta forma:
import { doIncreaseBy, doDecrementBy, doReset } from './actions/actions';
Es buena idea importar todo bajo un alias:

import * as actionsCreators from './actions/actions';

Y luego usar todo mediante este objeto:
dispatch( actionsCreators.doIncreaseBy(value) )

Quizás con 3 aún no se ve muy bien las ventajas pero fijate cuando tienes 10 o 15 que realmente es una buena idea.

						SECCION 03 INICIO DEL PROYECTO

Esta sección es totalmente opcional, el objetivo es crear una aplicación de React con TypeScript que nos sirva para las próximas secciones.

Aquí no veremos nada nuevo de React, crearemos rutas y dejaremos todo listo para las secciones que vienen.

