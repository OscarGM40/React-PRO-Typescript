					SECCION 16 USANDO WORKBOX EN LA PWA ANTERIOR

Realmente es muy engorroso usar el método anterior.En esta sección vamos a desahacer todo lo que hicimos en la sección anterior.Fijate que tuve que agregar muchas dependencias en producción,asi que llegaran al bundle final y puedo evitar esto.

WORKBOX permite crear y configurar Service Workers de manera muy rápida.Además,no pertenece a React,asi que lo que aprenda de Workbox lo puedo aplicar en cualquier entorno.

Instalaremos el Workbox-CLI que permite ejecutar comandos,hay uno muy útil(workbox-wizard) que creará un archivo ya configurado con Cache First With Network Fallback.

Veremos como guardar datos en la base de datos IndexDB local.Ojo,es una db asociada a la caché,si el usuario borra la cache eliminará los datos de IndexDB.

Sincronizaremos mediante BackgroundSync las tareas pendientes guardadas en IndexDB para que apenas se tenga conexión se realice esa operación almacenada como si nunca hubiera habido problemas con la conexión.
Mediante Workbox se puede realizar todo esto,que parece muy complejo,con muy pocas líneas de código.
Es sumamente cómodo y fácil trabajar con Workbox.

NOTA:fijate que la sección anterior era meramente ilustrativa
Por último también veré como expandir funcionalidad con módulos de Workbox.

TEMAS DE LA SECCIÓN:
  Workbox es una herramienta que compro Google y ahora le da soporte, que permite configuraciones poderosas, rápidas y fáciles para el manejo de nuestras PWAs.

Aquí aprenderemos:
1- Detectar Online y Offline desde React
2- Workbox
  a- Wizard
  b- Estrategias
  c- Background Sync
  d- IndexedDB
  e- Offline CRUD
3- Optimizaciones de nuestro service worker

				VIDEO 200 CONTINUACION DE NUESTRA APLICACIÓN

Se recomienda crear una rama ya que va a haber cambios drásticos.

					VIDEO 201 WORKBOX CLI WIZZARD

Fernando provee un asset para ir a la página oficial de Workbox:
https://developers.google.com/web/tools/workbox/guides/generate-service-worker/cli

Pide instalar de manera global la cli para workbox.Puedo ver que lo tengo instalado imprimiendo la version(workbox --version)

El objetivo de usar workbox-cli es tener un sw 	out-of-the-box rápidamente.Para ello voy a la app /frontend( pues es en la app de React donde quiero el SW) y tecleo el comando 'workbox wizard'.Esto creará un archivo de configuración nada más:

El folder del deploy es 'build',pre-cacheado todo,y dejo los nombres por defecto.

Bien,ahora si,ya puedo crear un service worker con esta configuración(veré el comando que necesito por la CLI:
workbox generateSW workbox-config.js

* Puedo ver que precacheara 664KB,es decir que esto va ser tomado del disco duro del cliente
Service worker will precache 13 URLs, totaling 664 kB.
Pudiera parecer que esto es todo,pero de igual forma que antes tuvimos que usar serviceWorker.register() falta decirle a la app que use el ServiceWorker.
Esta vez vamos a usar una etiqueta <script> en el public/index.html ya que la app de React está embebida alli y tiene visión

IMPORTANTE: siempre que esté usando react-scripts,por haber creado la app con create-react-app tengo acceso a la variable %NODE_ENV% que me indica el ambiente actual de la app.
Puedo ver que al usar serve -s build es : production
Ojo,sólo podemos ejecutar la instalación de ServiceWorker si estamos en producción,luego.Bien,entonces agregamos esto al index.html:
  <script>
      const isProduction= '%NODE_ENV%' === 'production';
      console.log('%NODE_ENV%')

      if(isProduction && 'serviceWorker' in navigator){
        navigator.serviceWorker.register('/sw.js');
      }else{
        console.log('no se pudo instalar el service worker')
      }
    </script>

Hago el yarn build,ya que he cambiado algo y ojo,esto borrará ese file sw.js que quiero pasarle al navigator.serviceWorker.register asi que tengo que ejecutar workbox generateSW ... tras el build.Esta vez si,tenemos nuestro SW instalado con Workbox,claro que no hace nada pues sólo lo hemos instalado.

				VIDEO 202 WORKBOX SW CONFIGURACION MANUAL

De aqui en adelante es todo cuesta abajo.Creamos un archivo en la raiz llamado 'sw-template.js'(el nombre es opcional.Fijate que debí desactivar el esLint:

/* eslint-disable no-undef */
importScripts(
  "https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js"
);
// eslint-disable-next-line no-restricted-globals
workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);


Fijate que en file workbox-config.js también añadi el archivo fuente  desde el que tomar los datos:
swDest: 'build/sw.js',
swSrc: 'src/sw-template.js',

Ahora,para que tome este archivo que hemos creado como template hay que usar otro comando:
>workbox injectManifest

* Puedo ver que funciona perfectamente
The service worker file was written to build/sw.js
The service worker will precache 14 URLs, totaling 678 kB.

NOTA: recuerda que Workbox permite crear SW facilmente
				
					VIDEO 203 WORKBOX CACHE STRATEGIES

NOTA: realmente todo lo que he visto lo puedo aplicar aqui también,podria usar perfectamente el código que ya he visto:

>self.addEventListener('install',(event) => {
 caches.open(...)
});

Sin embargo no tiene sentido hacerlo,obviamente,ya que workbox agiliza esto.
Bien,tal como teniamos el código podemos empezar a cachear segun estrategia en base a donde se haga la petición:
importScripts( "https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js");

workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);

workbox.routing.registerRoute(
  new RegExp(
    "https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
  ),
  new workbox.strategies.CacheFirst()
);
Fijate como le registro rutas al objeto workbox y especifico una estrategia.
Ya sólo falta ejecutar yarn PWA(fijate que no necesito hacer el build)
Puedo observar que el css es servido por el SW y al tener un SW puedo parar el servidor y la aplicación no caerá,pues tiene un SW en medio.

				VIDEO 204 VERIFICACION DE TOKEN OFFLINE

Bien,llegados a este punto puedo ver que CacheFirst y Network First tienen fallback al otro,y que CacheOnly y NetworkOnly no usan la fallback:
const { CacheFirst,NetworkFirst } = workbox.strategies;

registerRoute(
  ({url}) => url.pathname.startsWith('/api/auth/renew'),
  // new RegExp("http://localhost:4000/api/auth/renew"), 
  new workbox.strategies.NetworkFirst({
    cacheName: "renew-token",
  })
);

/*  */
registerRoute(
  ({url}) => url.pathname.startsWith('/api/events'),
  // new RegExp("http://localhost:4000/api/auth/renew"), 
  new NetworkFirst({
    cacheName: "cache-events",
  })
); 
Puedo ver que fue bastante sencillo gracias al trabajo que realiza por mi Workbox.Bien,pero,¿y si quiero hacer peticiones POST o DELETE offline?Workbox también ha pensado en eso y nos cubre con esa DB,además es muy fácil crear las conexiones.
Todo esto corresponde al módulo Workbox-BackgroundSync.

		VIDEO 205 BACKGROUNDSYNC - REALIZAR PETICIONES POST SIN CONEXION

Importante: todos estos módulos vienen ya preinstalados,sólo hay que activarlos.
NOTA:hay que ser muy meticuloso a la hora de usar el disco duro del cliente.No es buena idea meter toda una DB completa ni tampoco deberían estar los datos mucho tiempo.También debo recordar que es volátil,y que el usuario podría borrarlo ininitencionalmente

Bien,puedo ver en este ejemplo que la DB se usa como un plugin,y que requiere de la estrategia NetworkOnly,pues los post,delete,etc suelen ser muy dinámicos:

importScripts(...)
workbox.loadModule('workbox-background-sync);

const { BackgroundSyncPlugin } = workbox.backgroundSync;

const bgSyncPlugin = new BackgroundSyncPlugin('myQueueName',{
  maxRetentionTime: 24 * 60 // 24h es buena idea
});

registerRoute(
  new RegExp(...),
  new NetworkOnly({
    plugins:[bgSyncPlugin] }),
  'POST',<- pueden ser varias o hay que hacer otro controller??
);

En cuanto haga un Post sin conexion,ojo, se acumulará en la indexedDB el posteo y en cuanto haya conexion se realizara solo.Dado que no estamos usando sockets tengo que recargar el navegador una vez para verlo.Increible.

					VIDEO 206 TAREA - PUT Y DELETE

El PUT y DELETE van a ser algo más complicados por que usan un param dinámico.El truco está en usar la regexp apropiada para esa ocasion:
registerRoute(
  new RegExp("http://localhost:4000/api/events*"),
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  "PUT"
);

registerRoute(
  new RegExp("http://localhost:4000/api/events*"),
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  "DELETE"
);
NOTA:fijate que cuando use un ServiceWorker también se crea un Manifest(está arriba de Service Workers).El Manifest le dice a la aplicación varias cosas como el background-color o los iconos.

Puedo ir a public/manifest.json y ver qué es lo que está metiendo la app al Manifest,y obviamente añadirle cosas:

{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
Por ejemplo,le puedo cambiar el short_name y el name.Recuerda que es el manifest.json de la carpeta public

IMPORTANTE:cuando un browser detecte el service worker y el manifest veré una opción para instalar la app.Puedo instalarla y veré una app de escritorio(puedo desinstalarla despues)

Quedaría refactorizar un poco el código,ya que hemos repetido bastante,pero puedo observar lo fácil que fue implementar PWA en la aplicación de producción.

			VIDEO 207 OPTIMIZANDO NUESTRO SERVICE-WORKER.JS	




