					SECCION 16 USANDO WORKBOX EN LA PWA ANTERIOR

Realmente es muy engorroso usar el método anterior.En esta sección vamos a desahacer todo lo que hicimos en la sección anterior.Fijate que tuve que agregar muchas dependencias en producción,asi que llegaran al bundle final y puedo evitar esto.

WORKBOX permite crear y configurar Service Workers de manera muy rápida.Además,no pertenece a React,asi que lo que aprenda de Workbox lo puedo aplicar en cualquier entorno.

Instalaremos el Workbox-CLI que permite ejecutar comandos,hay uno muy útil(workbox-wizard) que creará un archivo ya configurado con Cache First With Network Fallback.

Veremos como guardar datos en la base de datos IndexDB local.Ojo,es una db asociada a la caché,si el usuario borra la cache eliminará los datos de IndexDB.

Sincronizaremos mediante BackgroundSync las tareas pendientes guardadas en IndexDB para que apenas se tenga conexión se realice esa operación almacenada como si nunca hubiera habido problemas con la conexión.
Mediante Workbox se puede realizar todo esto,que parece muy complejo,con muy pocas líneas de código.
Es sumamente cómodo y fácil trabajar con Workbox.

NOTA:fijate que la sección anterior era meramente ilustrativa
Por último también veré como expandir funcionalidad con módulos de Workbox.

TEMAS DE LA SECCIÓN:
  Workbox es una herramienta que compro Google y ahora le da soporte, que permite configuraciones poderosas, rápidas y fáciles para el manejo de nuestras PWAs.

Aquí aprenderemos:
1- Detectar Online y Offline desde React
2- Workbox
  a- Wizard
  b- Estrategias
  c- Background Sync
  d- IndexedDB
  e- Offline CRUD
3- Optimizaciones de nuestro service worker

				VIDEO 200 CONTINUACION DE NUESTRA APLICACIÓN

Se recomienda crear una rama ya que va a haber cambios drásticos.

					VIDEO 201 WORKBOX CLI WIZZARD

Fernando provee un asset para ir a la página oficial de Workbox:
https://developers.google.com/web/tools/workbox/guides/generate-service-worker/cli

Pide instalar de manera global la cli para workbox.Puedo ver que lo tengo instalado imprimiendo la version(workbox --version)

El objetivo de usar workbox-cli es tener un sw 	out-of-the-box rápidamente.Para ello voy a la app /frontend( pues es en la app de React donde quiero el SW) y tecleo el comando 'workbox wizard'.Esto creará un archivo de configuración nada más:

El folder del deploy es 'build',pre-cacheado todo,y dejo los nombres por defecto.

Bien,ahora si,ya puedo crear un service worker con esta configuración(veré el comando que necesito por la CLI:
workbox generateSW workbox-config.js

* Puedo ver que precacheara 664KB,es decir que esto va ser tomado del disco duro del cliente
Service worker will precache 13 URLs, totaling 664 kB.
Pudiera parecer que esto es todo,pero de igual forma que antes tuvimos que usar serviceWorker.register() falta decirle a la app que use el ServiceWorker.
Esta vez vamos a usar una etiqueta <script> en el public/index.html ya que la app de React está embebida alli y tiene visión

IMPORTANTE: siempre que esté usando react-scripts,por haber creado la app con create-react-app tengo acceso a la variable %NODE_ENV% que me indica el ambiente actual de la app.
Puedo ver que al usar serve -s build es : production
Ojo,sólo podemos ejecutar la instalación de ServiceWorker si estamos en producción,luego.Bien,entonces agregamos esto al index.html:
  <script>
      const isProduction= '%NODE_ENV%' === 'production';
      console.log('%NODE_ENV%')

      if(isProduction && 'serviceWorker' in navigator){
        navigator.serviceWorker.register('/sw.js');
      }else{
        console.log('no se pudo instalar el service worker')
      }
    </script>

Hago el yarn build,ya que he cambiado algo y ojo,esto borrará ese file sw.js que quiero pasarle al navigator.serviceWorker.register asi que tengo que ejecutar workbox generateSW ... tras el build.Esta vez si,tenemos nuestro SW instalado con Workbox,claro que no hace nada pues sólo lo hemos instalado.

				VIDEO 202 WORKBOX SW CONFIGURACION MANUAL

De aqui en adelante es todo cuesta abajo.Creamos un archivo en la raiz llamado 'sw-template.js'(el nombre es opcional.Fijate que debí desactivar el esLint:

/* eslint-disable no-undef */
importScripts(
  "https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js"
);
// eslint-disable-next-line no-restricted-globals
workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);


Fijate que en file workbox-config.js también añadi el archivo fuente  desde el que tomar los datos:
swDest: 'build/sw.js',
swSrc: 'src/sw-template.js',

Ahora,para que tome este archivo que hemos creado como template hay que usar otro comando:
>workbox injectManifest

* Puedo ver que funciona perfectamente
The service worker file was written to build/sw.js
The service worker will precache 14 URLs, totaling 678 kB.

NOTA: recuerda que Workbox permite crear SW facilmente
				
					VIDEO 203 WORKBOX CACHE STRATEGIES

NOTA: realmente todo lo que he visto lo puedo aplicar aqui también,podria usar perfectamente el código que ya he visto:

>self.addEventListener('install',(event) => {
 caches.open(...)
});

Sin embargo no tiene sentido hacerlo,obviamente,ya que workbox agiliza esto.
Bien,tal como teniamos el código podemos empezar a cachear segun estrategia en base a donde se haga la petición:
importScripts( "https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js");

workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);

workbox.routing.registerRoute(
  new RegExp(
    "https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
  ),
  new workbox.strategies.CacheFirst()
);
Fijate como le registro rutas al objeto workbox y especifico una estrategia.
Ya sólo falta ejecutar yarn PWA(fijate que no necesito hacer el build)
Puedo observar que el css es servido por el SW y al tener un SW puedo parar el servidor y la aplicación no caerá,pues tiene un SW en medio.

				VIDEO 204 VERIFICACION DE TOKEN OFFLINE

Bien,llegados a este punto puedo ver que CacheFirst y Network First tienen fallback al otro,y que CacheOnly y NetworkOnly no usan la fallback:
const { CacheFirst,NetworkFirst } = workbox.strategies;

registerRoute(
  ({url}) => url.pathname.startsWith('/api/auth/renew'),
  // new RegExp("http://localhost:4000/api/auth/renew"), 
  new workbox.strategies.NetworkFirst({
    cacheName: "renew-token",
  })
);

/*  */
registerRoute(
  ({url}) => url.pathname.startsWith('/api/events'),
  // new RegExp("http://localhost:4000/api/auth/renew"), 
  new NetworkFirst({
    cacheName: "cache-events",
  })
); 
Puedo ver que fue bastante sencillo gracias al trabajo que realiza por mi Workbox.Bien,pero,¿y si quiero hacer peticiones POST o DELETE offline?Workbox también ha pensado en eso y nos cubre con esa DB,además es muy fácil crear las conexiones.
Todo esto corresponde al módulo Workbox-BackgroundSync.

		VIDEO 205 BACKGROUNDSYNC - REALIZAR PETICIONES POST SIN CONEXION

Importante: todos estos módulos vienen ya preinstalados,sólo hay que activarlos.
NOTA:hay que ser muy meticuloso a la hora de usar el disco duro del cliente.No es buena idea meter toda una DB completa ni tampoco deberían estar los datos mucho tiempo.También debo recordar que es volátil,y que el usuario podría borrarlo ininitencionalmente

Bien,puedo ver en este ejemplo que la DB se usa como un plugin,y que requiere de la estrategia NetworkOnly,pues los post,delete,etc suelen ser muy dinámicos:

importScripts(...)
workbox.loadModule('workbox-background-sync);

const { BackgroundSyncPlugin } = workbox.backgroundSync;

const bgSyncPlugin = new BackgroundSyncPlugin('myQueueName',{
  maxRetentionTime: 24 * 60 // 24h es buena idea
});

registerRoute(
  new RegExp(...),
  new NetworkOnly({
    plugins:[bgSyncPlugin] }),
  'POST',<- pueden ser varias o hay que hacer otro controller??
);

En cuanto haga un Post sin conexion,ojo, se acumulará en la indexedDB el posteo y en cuanto haya conexion se realizara solo.Dado que no estamos usando sockets tengo que recargar el navegador una vez para verlo.Increible.

					VIDEO 206 TAREA - PUT Y DELETE

El PUT y DELETE van a ser algo más complicados por que usan un param dinámico.El truco está en usar la regexp apropiada para esa ocasion:
registerRoute(
  new RegExp("http://localhost:4000/api/events*"),
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  "PUT"
);

registerRoute(
  new RegExp("http://localhost:4000/api/events*"),
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  "DELETE"
);
NOTA:fijate que cuando use un ServiceWorker también se crea un Manifest(está arriba de Service Workers).El Manifest le dice a la aplicación varias cosas como el background-color o los iconos.

Puedo ir a public/manifest.json y ver qué es lo que está metiendo la app al Manifest,y obviamente añadirle cosas:

{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
Por ejemplo,le puedo cambiar el short_name y el name.Recuerda que es el manifest.json de la carpeta public

IMPORTANTE:cuando un browser detecte el service worker y el manifest veré una opción para instalar la app.Puedo instalarla y veré una app de escritorio(puedo desinstalarla despues)

Quedaría refactorizar un poco el código,ya que hemos repetido bastante,pero puedo observar lo fácil que fue implementar PWA en la aplicación de producción.

			VIDEO 207 OPTIMIZANDO NUESTRO SERVICE-WORKER.JS	

En realidad puedo mandar varias cosas al registerRoute.Puedo mandarle una callback como primer argumento,si regresa true pasará al segundo.En esta callback puedo acceder a los objetos request y url:

workbox.routing.registerRoute(
  ({request,url}) => {
    console.log(request,url)
    return false;
  },
  new workbox.strategies.CacheFirst()
);

Request {method: 'GET', url: 'https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css', headers: Headers, destination: 'style', referrer: 'http://localhost:3000/', …} 
URL {origin: 'https://stackpath.bootstrapcdn.com', protocol: 'https:', username: '', password: '', host: 'stackpath.bootstrapcdn.com', …}
Puedo ver que tengo visión sobre cualquier metadata prácticamente.

Sabiendo esto puedo resumir bastante el código:

const cacheNetworkFirst = [`/api/auth/renew`, `/api/events`];

const cacheCacheFirst = [
  "https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css",
  "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css",
];

workbox.routing.registerRoute(
  ({ request, url }) => {
    if cacheNetworkFirst.includes(url.pathname) return true;
    return false;
  },
  new NetworkFirst()
);

registerRoute(
  ({request, url}) => {
    if (cacheCacheFirst.includes(url.href)) {
      return true;
    } else {
      return false;
    }
  },
  new CacheFirst()
);

Ojo que para las CDNs es url.href(aunque también se puede hacer de otras formas).

				VIDEO 208 MOSTRAR MENSAJES DE ONLINE - OFFLINE

Para realizar esto vamos a usar el paquete 'react-detect-offline':
>npm i react-detect-offline

Hay dos estrategias para implementar esta libreria:

UNA:
import { Offline, Online } from "react-detect-offline";

const App = () => (
  <div>
    <Online>Only shown when you're online</Online>
    <Offline>Only shown offline (surprise!)</Offline>
  </div>
);

DOS:
<Detector
  render={({ online }) => (
    <div className={online ? "normal" : "warning"}>
      You are currently {online ? "online" : "offline"}
    </div>
  )}
/>

Al final pongo algo asi en la navbar:
   <Online>
        <span className="text-success">Online</span>
      </Online>
      <Offline>
        <span className="text-danger">Offline</span>
      </Offline>

Fijate como aunque fuera una sección introductoria me ha servido mucho para entender una PWA y workbox.

		SECCION 17 MAPAS-MARCADORES-POLYLINES  WITH MAPBOX

Esta es una sección bonus añadida después de haber terminado el curso, la cual tiene por objetivo aprender:

1- Uso de Mapbox con TypeScript
2- Rutas y direcciones
3- Marcadores
4- Comunicación entre contextos
5- Distancia entre dos puntos
6- Duración aproximada del viaje

Es una sección bien interesante que les puede servir mucho, especialmente si quieren realizar cualquier trabajo con mapas en sus aplicaciones móviles o web.

			VIDEO 212-213 INICIO - CREANDO EL CONTEXTO DE LUGARES

Creamos una nueva app en typescript,siguiendo las instrucciones de Fernando.Fijate que usaremos el ContextAPI por comodidad,y que Fernando sugiere usar tres archivos por cada Contexto que use:

* Uno para el createContext(PlacesContext.ts):

import { createContext } from "react";

export interface PlacesContextProps {
  isLoading: boolean
  userLocation?: [number, number] 
}

export const PlacesContext = createContext({} as PlacesContextProps);

* Otro para el Provider:
import { PlacesContext } from "./PlacesContext";

export interface PlacesState {
  isLoading: boolean;
  userLocation?: [number, number];

}

const INITIAL_STATE:PlacesState = {
  isLoading: true,
  userLocation: undefined
};

type  Children = {
  children: JSX.Element | JSX.Element[]
}
export const PlacesProvider = ({ children }:Children) => {

  return (
    <PlacesContext.Provider value={{ 
      isLoading: INITIAL_STATE.isLoading,
      userLocation: INITIAL_STATE.userLocation,
     }}>
      {children}
    </PlacesContext.Provider>
  );
};

* Otro para la función pura reductora(fijate que el createContext y éste no devuelven JSX):
import { PlacesState } from "./PlacesProvider";

type PlacesAction = {
  type: "setUserLocation",
  payload: [number, number]

}

export const placesReducer = (state: PlacesState, action: PlacesAction): PlacesState => {

  switch (action.type) {
    case "setUserLocation":
      return {
        ...state,
        isLoading: false,
        userLocation: action.payload
      }
    default:
      return state;
  }
}

Para usar la función hay que usar el hook useReducer:

export const PlacesProvider = ({ children }: Children) => {
  const [state, dispatch] = useReducer(placesReducer, INITIAL_STATE);

  return (
    <PlacesContext.Provider
      value={{
        ...state,
      }}
    >
Fijate que con esparcir el state fue suficiente.En este punto debo memorizar estos pasos ya que es un cascarón perfecto para implementar la ContextAPI.
Fijate también que queda algun paso adicional para el dispatch,cuando lo resuelva actualizar el gist.

			VIDEO 215 OBTENER LA GEOLOCALIZACIÓN DEL HOST DEL USUARIO


Lo primero es ir a las ChromeDevTools,clickar en los tres puntos,despues en More Tools y despues en sensors ,alli puedo meter una lngLat custom(anécdotico).

Para obtener la geolocalización usaremos la navigator API ya integrada en del browser :

export const getUserLocation = async (): Promise<[number, number]> => {
  return new Promise((resolve, reject) => {
    /* también tengo watch para geolocalizar en movimiento */
    navigator.geolocation.getCurrentPosition(
      ({ coords }) => {
        resolve([coords.latitude, coords.longitude]);
      },
      (err) => {
        alert('no se pudo obtener la geolocalización')
        reject("Error: " + err);
      })
  })
}
Primeramente creo una Promise que resuelva a lo que yo quiero y despues la llamo en un efecto,para que sea la primera accion que se dispare:

export const PlacesProvider = ({ children }: Children) => {
  const [state, dispatch] = useReducer(placesReducer, INITIAL_STATE);

  useEffect(() => {
    ( async () => {
      const lngLat = await getUserLocation();
      dispatch({
        type: "setUserLocation",
        payload: lngLat,
    })})();
},[]);

			VIDEO 216 MOSTRAR LA GEOLOCALIZACIÓN DEL USUARIO EN PANTALLA

Una vez obtenida con la navigator API,disparada la accion inmediatamente se cargue la app queremos mostrarla por la UI.
Fijate que es mejor snipet rafc o tsrafc que rafce.

export const MapView = () => {
  const { isLoading, userLocation } = useContext(PlacesContext);

  if (isLoading) {
    return <Loading />;
  }

  return <div>{userLocation?.join("")}</div>;
};
Recuerda que puedo ir a Components y en los providers cambiar ese isLoading.Hazlo

					 VIDEO 217 MOSTRAR MAPA DE MAPBOX

Vamos a usar mapbox por motivos obvios.Fijate que la generación de tokens que tienen es muy buena,pudiendo incluso restringir las URLS desde las que se envia el token,para que no lo usen más que en mi web.
Para ver como se instala voy a documentación.Alli ya me dicen que puedo usar una CDN o la libreria mapbox-gl de npm

Genero un token y me traigo las cdns o uso npm.Recuerda que hay que esperar al DOM para cerciorarme que el div donde voy a meter el mapa existe:

 const mapDiv = useRef<HTMLDivElement>(null);

  useLayoutEffect(() => {
    if (!isLoading) {
      new Map({
        container: mapDiv?.current!,
        style: 'mapbox://styles/mapbox/streets-v11',
        center: userLocation,
        zoom: 4,
      });
    }
  }, [isLoading,userLocation]);
  
  if (isLoading) {
    return <Loading />;
  }

  return (
    <div
      ref={mapDiv}
      style={{
        height: "100vh",
        width: "100vw",
        position: "fixed",
        top: 0,
        left: 0,
      }}
    >
    </div>
  ; 

				VIDEO 218 CREAR EL CONTEXTO PARA EL MAPA

Lo más importante es que mapbox ya me da el tipo Map para tipar una propiedad.Sabiendo esto,nuestro contexto podria lucir en un primer momento como esto:

import { Map } from "mapbox-gl";
import { createContext } from "react";

interface MapContextProps {
  isMapReady: boolean;
  map?: Map;
}

export const MapContext = createContext({} as MapContextProps);

En cuanto al Provider fijate como luce.De nuevo la clave es que map sea undefined en un principio y opcional y recuerda que los children son un JSX.Element o un JSX.Element[]:

export interface MapState {
  isMapReady: boolean;
  map?:Map;
}

const INITIAL_STATE: MapState = {
  isMapReady: false,
  map: undefined,
};

type Children = {
  children: JSX.Element | JSX.Element[];
};

export const MapProvider = ({ children }: Children) => {
  const [state, dispatch] = useReducer(mapReducer, INITIAL_STATE);

  return (
    <MapContext.Provider
      value={{
        ...state,
      }}
    >
      {children}
    </MapContext.Provider>
  )
};

Y en cuanto al reducer de nuevo no nos complicamos:

type MapAction = {
  type: "setMap",
  payload: Map

}

export const mapReducer = (state: MapState, action: MapAction): MapState => {

  switch (action.type) {
    case "setMap":
      return {
        ...state,
        map: action.payload
      }
    default:
      return state;
  }
}
Genial.Recuerda usar el index para exportaciones masivas.Y fijate como puedo exportar un import por default:
export {default as Comp1} from './Comp1.jsx';
export {default as Comp2} from './Comp2.jsx';
Amazing,ya puedo volver a mi tsrafce cual prehistoric

Por último,si no quiero tener que tipar el Children puedo usar React.FC(de functional component) asin:

const CustomComponent: React.FC = ({ children }) => {
  return (
    <div>{children}</div>
  )
}

			VIDEO 219 ESTABLECER EL MAPA EN EL CONTEXTO

Es importante entender que realmente puedo abastecer a mi contexto con lo que quiera,puedo crear cualquier función y proveeerla a la APP.Por ejemplo,puedo crear una función que llame al dispatch de una acción y abastecer esa función:

export const MapProvider = ({ children }: Children) => {
  const [state, dispatch] = useReducer(mapReducer,INITIAL_STATE);

  const setMap = (map:Map) => {
    dispatch({
      type: "setMap",
      payload: map,
    });
  }
  
  return (
    <MapContext.Provider
      value={{
       ...state,
        setMap,
      }}
    >

Fijate que yo normalmente envio el dispatch y ya dispararé la acción.Ahora donde quiera puedo llamar al setMap que disparará esa acción.La verdad es que son formas distintas de hacerlo,puede ser útil esta aproximación.

			VIDEO 220 MARCADORES,POPUPS Y BOTON DE UBICACION

Bien,ahora si,ya queda esclarecido porqué ha creado una función custom y la abastece,ya que no sólo va a establecer el mapa sino que sacaré un marcador:

 const setMap = (map:Map) => { 

    const myLocationPopup = new Popup()
    .setHTML(`
      <h4>Aquí estoy</h4>
      <p>En algún lugar del mundo</p>`);
    
    const newMarker = new Marker({
      color:"#61dafb",
      draggable: true,
    })
    .setLngLat(map.getCenter())
    .setPopup(myLocationPopup)
    .addTo(map);
    
    dispatch({
      type: "setMap",
      payload: map,
    });
  }
Fijate como esta vez Fernando ha mejorado en esta aplicación de mapas
NOTA: realmente hay bastantes temas en la libreria,vamos a usar uno más bonito que el normal,fijate que incluso puedo crear mis propios temas.

Bien,y por último,dado que tengo acceso al map y a la ubicación del usuario puedo crear un botón que devuelva al usuario a la posición actual.La clave es map.flyTo() y mandarle la userLocation.

const onClick = () => {
    if(!isMapReady) throw new Error("Map is not ready, please wait");
    if(!userLocation) throw new Error("No hay ubicación de usuario")
    
    if (isMapReady) {
      map?.flyTo({
        center: userLocation,
        zoom: 12,
      });
    }
  }

IMPORTANTE: puedo crear cualquier cosa realmente,sólo hay que tener la imaginación para ello,en este caso fijate como Fernando crea un componente que es el icono de React y lo pone en fixed abajo a la derecha,quedando espectacular.

const ReactLogo = () => {
  return <img src={reactLogo} alt="react-logo" style={{
    position: "fixed",
    bottom:"20px",
    right:"20px",
    width:"130px",
    zIndex:9,
  }}/>;
};
export default ReactLogo;
No debo minusvalorar a position:fixed.

				VIDEO 222 SEARCH BAR Y DEBOUNCE MANUAL

Vamos a crear una caja de búsqueda que nos permita introducir ciudades,etc...
NOTA:recuerda que cuando dos márgenes se encuentran se produce el colapso de márgenes(margin-bottom:50px y margin-top:40px producirán un márgen de 50).Siempre prevalecedará el margin con mayor valor.
IMPORTANTE:el colapso de margenes también lo hereda el padre.Si tengo un <div><h2> y le doy un margin-top de 40px al h2 el div se apropiará de él y tendrá ese margin top(los hijos pasan el margin al padre).Esto sólo sucede si se tocan los márgenes,pudiendo usar un padding de 0.1px en el padre para separarlo del hijo

En cuanto a box-sizing puedo usar content-box o border-box.Normalmente se usa la segunda,y lo que hace es sumar los margins,paddings y borders al contenido de la caja.Si yo le doy 300 de alto,10 de margin y 10 de pading me quedarán 260px para el contenido,y si le doy un border de 1px quedarán 258.

Bien,volviendo al video fijate de nuevo que fácil es crear el input de busqueda con la position fixed pegandolo a cualquier esquina.Además,vamos a implementar un debounceTime manualmente,para no usar una dependencia:

export const SearchBar = () => {
  const debounceRef = useRef<NodeJS.Timeout>(); <- fijate que debounceRef es un simple setTimeout\interval

  const handleChange = (event:ChangeEvent<HTMLInputElement>) => {
   if(debounceRef.current){
     clearTimeout(debounceRef.current);
   } <- si se pulsa una tecla durante esos 350ms vuelvo a resetear el interval
	
  debounceRef.current = setTimeout( () => {
  console.log(event.target.value)
},350)

NOTA:fijate que sencillo ha sido implementar el debounceTime manualmente,no puede ser más sencillo y ten en cuenta que es algo muy útil.Puedo observar que es una tontería implementar paquetes de terceros que pudieran romper la aplicación en un futuro para algo tan nimio.

		VIDEO 223 BUSCAR LUGARES BASADOS EN EL RESULTADO DE LA BUSQUEDA

Para realizar busquedas por coordenadas,nombres de ciudad,etc puedo ver en la documentación que debo apuntar por GET a:
https://api.mapbox.com/geocoding/v5/mapbox.places/central.json?proximity=ip&types=place%2Cpostcode%2Caddress&language=es&access_token=YOUR_MAPBOX_ACCESS_TOKEN

Llegados a este punto vamos a crearnos una nueva instancia de axios para realizar comodamente las peticiones.


const searchApi = axios.create({
  baseURL: 'https://api.mapbox.com/geocoding/v5/mapbox.places',
  params:{
    limit:5,
    language:'es',
    access_token: "pk.ey..."
  }
})

export default searchApi;
NOTA:en cuanto tenga varios queryParams lo mejor es crear instancias de axios.De echo siempre es buena idea crear una mandando el token para no repetirme.
Vamos a abastecer la función en el PlacesContext:

 const searchPlacesByTerm = async (query:string) => {
    if(query.length === 0) return []; // limpiar state
  
    if(!state.userLocation) throw new Error("no hay ubicación del usuario")

    const resp = await searchApi.get(`/${query}.json`, {
      params: {
       /*  proximity:state.userLocation[0] + "," + state.userLocation[1], */
       lat: state.userLocation[0],
       lng: state.userLocation[1],

    }});
    console.log(resp.data,'resp')
    return resp.data;
  }
Ya sólo es llamarla en el handleChange.

			VIDEO 224 COLOCAR EL TIPO DE DATO Y ALMACENARLO EN EL STATE

Tenemos un problema con el tipado(ya que hemos tipado como (query:String)=>Promise<any>.Como siempre,copio la respuesta y saco el tipado.

NOTA: si bien puedo usar la web quicktype.io también hay una extensión de VSCode para ello.La extensión se llama Paste JSON as Code y es de quicktype.Simplemente tengo que pegar un JSON y con CTRL+SHIFT+p elegir Paste JSON as Code y darle un nombre a la interfaz principal cuando me lo pida.

Con todo esto ya puedo tipar la petición y devolver el arreglo de features únicamente:
 const resp = await searchApi.get<PlacesResponse>(`/${query}.json`, {
      params: {
       lat: state.userLocation[0],
       lng: state.userLocation[1],

    }});
    return resp.data.features;

En cuanto a las acciones vamos a crearnos más:
type PlacesAction =
  | { type: "setUserLocation", payload: [number, number] }
  | { type: "setLoadingPlaces" }
  | { type: "setPlaces", payload: Feature[] }

Fijate que esa sintaxis parece la más adecuada actualmente.Ahora si,ya puedo disparar estas acciones(fijate en la conveniencia de tener el dispatch a mano al crear mis acciones en el Provider):

  const searchPlacesByTerm = async (query: string) => {
    if (query.length === 0) return []; // limpiar state
    if (!state.userLocation) throw new Error("no hay ubicación del usuario");
    dispatch({type:'setLoadingPlaces'});

    const resp = await searchApi.get<PlacesResponse>(`/${query}.json`, {
      params: {
        lat: state.userLocation[0],
        lng: state.userLocation[1],
      },
    });
    dispatch({ type: "setPlaces", payload: resp.data.features });
    return resp.data.features;
  };
	
			VIDEO 225 MOSTRAR ESOS LUGARES ENCONTRADOS

Con los lugares ya cargados en nuestro state ya simplemente es pintar un marcador para cada uno.Crearemos un componente especializado en mostrar todos estos lugares.

Asin:recuerda preguntar por el inglés y ser modesto y amable con tod@s.
export const SearchResults = () => {
  const { places, isLoadingPlaces } = useContext(PlacesContext);

  if(isLoadingPlaces) {
    return <LoadingPlaces />
  }
  if(places.length === 0) {
    return <></>
  }
  return (
    <ul className="list-group mt-3">
      {places.map((place) => (
        <li 
          key={place.id} 
          className="list-group-item list-group-item-action">
          <h6>{place.text_es}</h6>
          <p className="text-muted" 
          style={{ fontSize: 12 }}
          >
            {place.place_name}
          </p>
          <button className="btn btn-outline-primary">Direcciones</button>
        </li>
      ))}
    </ul>
  );
};

Aún falta mostrar en el mapa los resultados,pero ya puedo verlos en la lista.

			VIDEO 226 COLOCAR MARCADORES POR CADA SITIO ENCONTRADO

NOTA:hay ciertas propiedades CSS que se heredan automáticamente.Si tengo un div y dentro un h2 propiedades como el color o font-family las heredará el h2 si se las declaro al div padre.
Si quiero puedo volver al valor inicial con el value 'initial':
div {
  text-align:center
}
div > h2 {
  text-align:initial; <- ahora en vez de center(que lo iba a tener por herencia) se pondrá en left,que es como estaba antes de heredar el center
Y de igual manera puedo heredar borders,paddings,...
div{ 
border: 1px solid black
}
div > h2 {
  border: inherit<- al heredar el borde coge el del padre que es el div

Siempre hay que tener en cuenta la herencia e ir al inspector en caso de problemas
Bien,volviendo al video,nos faltó resetear cuando el input esté vacío:
 
   if (query.length === 0) {
      dispatch({type:'setPlaces', payload:[]});
      return [];
    }
Mandar un arreglo vacio como payload nos valdrá.Bien,para los marcadores vamos a crear una accion sincrona:

type MapAction =
  | { type: "setMap", payload: Map }
  | { type: "setMarkers", payload: Marker[] }

    case "setMarkers":
      return {
        ...state,
        markers: action.payload
      }

 const { places } = useContext(PlacesContext);

  useEffect(() => {
    state.markers?.forEach((marker) => marker.remove());
    const newMarkers: Marker[] = [];

    for (const place of places) {
      const [lng, lat] = place.center;
      const popup = new Popup().setHTML(`
        <h6>${place.text_es}</h6>
        <p class="text-muted" style="font-size: 12px">
          ${place.place_name_es}
        </p>
      `);
      const newMarker = new Marker()
        .setPopup(popup)
        .setLngLat([lng, lat])
        .addTo(state.map!);
      newMarkers.push(newMarker);
    }
    // limpiar polylines
    dispatch({type:'setMarkers', payload: newMarkers});
  }, [state.markers, places, state.map]);

* Fijate que de nuevo uso new Popup().setHTML,new Marker,etc añadiendolo al map.

			VIDEO 227 VOLAR Y ACTIVAR EL LUGAR SELECCIONADO

Queremos que al hacer click en un lugar concreto tras hacer la query naveguemos hacia él,dado que mejora la experiencia de usuario.También queremos activarlo,ponerlo como marcador activo.

Realmente es bastante sencillo,en el list item implemento el evento click pasandole el place,que lo tengo a mano en la iteración.
 <li 
   key={place.id} 
   className="list-group-item list-group-item-action pointer"
   onClick={() => onPlaceClicked(place)} 
   >
Y esa función llamará a map.flyTo():
 const [activeId, setActiveId] = useState("");

 const onPlaceClicked = (place:Feature) => {
    const  [lng, lat] = place.center;

    map?.flyTo({
      center: [lng, lat],
      zoom: 15,
    });
  setActiveId(place.id)
  }
Fijate que con un simple estado local  podemos darle un estilo si se hace click en el marcador,y realmente es algo que no es necesario que salga de este componente.Nos faltaría trazar la ruta desde nuestra ubicación hasta la que se hecho click

			VIDEO 228 DIRECTIONS API - TRAZOS ENTRE DOS PUNTOS

Esto realmente es otra feature de esta grandisima libreria de mapas.Puedo ir a documentación y buscar alli por directions:
https://docs.mapbox.com/playground/directions/
Puedo ver alli que hay varias opciones(traffic,driving,walking o cycling se refiere a transporte público,coche propio,caminando o en bici,respectivamente)
Alternatives muestra rutas alternativas y steps da las instrucciones fragmentadas en pasos.
Usaremos geojson ya que no es necesario desencriptar las coordenadas,aunque sea un poco menos preciso.

NOTA: %3B es un punto y coma,%2C parece que es una coma.Bien,creamos una nueva instancia de axios que apunte al endpoint que nos sugieren con las opciones que queremos:

const directionsApi = axios.create({
  baseURL: 'https://api.mapbox.com/directions/v5/mapbox/driving',
  params: {
    alternatives:false,
    geometries:"geojson",
    overview:"simplified",
    steps:false, 
    language: 'es',
    access_token: "pk.ey"
  }
})

export default directionsApi;

			VIDEO 230 MOSTRAR LA POLYLINE EN EL MAPA 

Para mostrar la polyline es seguir la documentación,son varios pasos:
  const bounds = new LngLatBounds(start, start);

    for (const coord of coords) {
      const newCoord: [number, number] = [coord[0], coord[1]];
      bounds.extend(newCoord);
    }
    /* debo dejar un pequeño padding */
    state.map?.fitBounds(bounds, { padding: 200 });

    /* esto es como luce una polyline(falta agregarla) */
    const sourceData: AnySourceData = {
      type: "geojson",
      data: {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            properties: {},
            geometry: {
              type: "LineString",
              coordinates: coords,
            },
          },
        ],
      },
    };
    /* solo puedo tener una polyline,hay que borrar la anterior Para ello hay que borrar tanto la layer como el source de datos */
    if (state.map?.getLayer("RouteString")) {
      state.map?.removeLayer("RouteString");
      state.map?.removeSource("RouteString");
    }
    state.map?.addSource("RouteString", sourceData);
    state.map?.addLayer({
      id: "RouteString",
      type: "line",
      source: "RouteString",
      layout: {
        "line-join": "round",
        "line-cap": "round",
      },
      paint: {
        "line-color": "#61dafb",
        "line-width": 4,
      },
    });	

			VIDEO 231 DESPLEGAR LA APLICACIÓN

Mapbox tiene un pequeño problema con Babel,al hacer el build y desplegarlo veré que Babel transpilará mal.La solución es indicar a Babel que no transpile la libreria entera,hay varias formas de hacerlo(lo tengo en la documentación).

Dado que estamos con create-react-app no puedo acceder al webpack.config pero si que puedo usar esto:
import mapbox from '!mapbox-gl'; 
Puedo interpretar ese ! como 'babel,no transpiles esta libreria'.Es muy poco común,pero es justo lo que quiero.(investigar sobre la arroba)
	
Sin embargo esto dará otro error ya que typescript confunde completamente el nombre y piensa que es otra libreria diferente y no encuentra los type definitions.
En este punto lo mejor es ignorar los errores:
//@ts-ignore
// eslint-disable-next-line import/no-webpack-loader-syntax
import mapboxgl from "!mapbox-gl";
Hacer lo mismo para todo el proyecto.Bien,pudiera parecer que es suficiente,pero no voy a poder hacer el build,dado que esta sintaxis(la !) no está permitida.

Yo lo solucioné con la segunda linea.Fernando usó /* eslint import/no-wepack-loader-syntax:off */
Ya con esto si que funcionará la aplicación,dado que Babel ignorará a mapbox.

