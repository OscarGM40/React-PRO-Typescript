					SECCION 16 USANDO WORKBOX EN LA PWA ANTERIOR

Realmente es muy engorroso usar el método anterior.En esta sección vamos a desahacer todo lo que hicimos en la sección anterior.Fijate que tuve que agregar muchas dependencias en producción,asi que llegaran al bundle final y puedo evitar esto.

WORKBOX permite crear y configurar Service Workers de manera muy rápida.Además,no pertenece a React,asi que lo que aprenda de Workbox lo puedo aplicar en cualquier entorno.

Instalaremos el Workbox-CLI que permite ejecutar comandos,hay uno muy útil(workbox-wizard) que creará un archivo ya configurado con Cache First With Network Fallback.

Veremos como guardar datos en la base de datos IndexDB local.Ojo,es una db asociada a la caché,si el usuario borra la cache eliminará los datos de IndexDB.

Sincronizaremos mediante BackgroundSync las tareas pendientes guardadas en IndexDB para que apenas se tenga conexión se realice esa operación almacenada como si nunca hubiera habido problemas con la conexión.
Mediante Workbox se puede realizar todo esto,que parece muy complejo,con muy pocas líneas de código.
Es sumamente cómodo y fácil trabajar con Workbox.

NOTA:fijate que la sección anterior era meramente ilustrativa
Por último también veré como expandir funcionalidad con módulos de Workbox.

TEMAS DE LA SECCIÓN:
  Workbox es una herramienta que compro Google y ahora le da soporte, que permite configuraciones poderosas, rápidas y fáciles para el manejo de nuestras PWAs.

Aquí aprenderemos:
1- Detectar Online y Offline desde React
2- Workbox
  a- Wizard
  b- Estrategias
  c- Background Sync
  d- IndexedDB
  e- Offline CRUD
3- Optimizaciones de nuestro service worker

				VIDEO 200 CONTINUACION DE NUESTRA APLICACIÓN

Se recomienda crear una rama ya que va a haber cambios drásticos.

					VIDEO 201 WORKBOX CLI WIZZARD

Fernando provee un asset para ir a la página oficial de Workbox:
https://developers.google.com/web/tools/workbox/guides/generate-service-worker/cli

Pide instalar de manera global la cli para workbox.Puedo ver que lo tengo instalado imprimiendo la version(workbox --version)

El objetivo de usar workbox-cli es tener un sw 	out-of-the-box rápidamente.Para ello voy a la app /frontend( pues es en la app de React donde quiero el SW) y tecleo el comando 'workbox wizard'.Esto creará un archivo de configuración nada más:

El folder del deploy es 'build',pre-cacheado todo,y dejo los nombres por defecto.

Bien,ahora si,ya puedo crear un service worker con esta configuración(veré el comando que necesito por la CLI:
workbox generateSW workbox-config.js

* Puedo ver que precacheara 664KB,es decir que esto va ser tomado del disco duro del cliente
Service worker will precache 13 URLs, totaling 664 kB.
Pudiera parecer que esto es todo,pero de igual forma que antes tuvimos que usar serviceWorker.register() falta decirle a la app que use el ServiceWorker.
Esta vez vamos a usar una etiqueta <script> en el public/index.html ya que la app de React está embebida alli y tiene visión

IMPORTANTE: siempre que esté usando react-scripts,por haber creado la app con create-react-app tengo acceso a la variable %NODE_ENV% que me indica el ambiente actual de la app.
Puedo ver que al usar serve -s build es : production
Ojo,sólo podemos ejecutar la instalación de ServiceWorker si estamos en producción,luego.Bien,entonces agregamos esto al index.html:
  <script>
      const isProduction= '%NODE_ENV%' === 'production';
      console.log('%NODE_ENV%')

      if(isProduction && 'serviceWorker' in navigator){
        navigator.serviceWorker.register('/sw.js');
      }else{
        console.log('no se pudo instalar el service worker')
      }
    </script>

Hago el yarn build,ya que he cambiado algo y ojo,esto borrará ese file sw.js que quiero pasarle al navigator.serviceWorker.register asi que tengo que ejecutar workbox generateSW ... tras el build.Esta vez si,tenemos nuestro SW instalado con Workbox,claro que no hace nada pues sólo lo hemos instalado.

				VIDEO 202 WORKBOX SW CONFIGURACION MANUAL

De aqui en adelante es todo cuesta abajo.Creamos un archivo en la raiz llamado 'sw-template.js'(el nombre es opcional.Fijate que debí desactivar el esLint:

/* eslint-disable no-undef */
importScripts(
  "https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js"
);
// eslint-disable-next-line no-restricted-globals
workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);


Fijate que en file workbox-config.js también añadi el archivo fuente  desde el que tomar los datos:
swDest: 'build/sw.js',
swSrc: 'src/sw-template.js',

Ahora,para que tome este archivo que hemos creado como template hay que usar otro comando:
>workbox injectManifest

* Puedo ver que funciona perfectamente
The service worker file was written to build/sw.js
The service worker will precache 14 URLs, totaling 678 kB.

NOTA: recuerda que Workbox permite crear SW facilmente
				
					VIDEO 203 WORKBOX CACHE STRATEGIES

NOTA: realmente todo lo que he visto lo puedo aplicar aqui también,podria usar perfectamente el código que ya he visto:

>self.addEventListener('install',(event) => {
 caches.open(...)
});

Sin embargo no tiene sentido hacerlo,obviamente,ya que workbox agiliza esto.
Bien,tal como teniamos el código podemos empezar a cachear segun estrategia en base a donde se haga la petición:
importScripts( "https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js");

workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);

workbox.routing.registerRoute(
  new RegExp(
    "https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
  ),
  new workbox.strategies.CacheFirst()
);
Fijate como le registro rutas al objeto workbox y especifico una estrategia.
Ya sólo falta ejecutar yarn PWA(fijate que no necesito hacer el build)
Puedo observar que el css es servido por el SW y al tener un SW puedo parar el servidor y la aplicación no caerá,pues tiene un SW en medio.

				VIDEO 204 VERIFICACION DE TOKEN OFFLINE

Bien,llegados a este punto puedo ver que CacheFirst y Network First tienen fallback al otro,y que CacheOnly y NetworkOnly no usan la fallback:
const { CacheFirst,NetworkFirst } = workbox.strategies;

registerRoute(
  ({url}) => url.pathname.startsWith('/api/auth/renew'),
  // new RegExp("http://localhost:4000/api/auth/renew"), 
  new workbox.strategies.NetworkFirst({
    cacheName: "renew-token",
  })
);

/*  */
registerRoute(
  ({url}) => url.pathname.startsWith('/api/events'),
  // new RegExp("http://localhost:4000/api/auth/renew"), 
  new NetworkFirst({
    cacheName: "cache-events",
  })
); 
Puedo ver que fue bastante sencillo gracias al trabajo que realiza por mi Workbox.Bien,pero,¿y si quiero hacer peticiones POST o DELETE offline?Workbox también ha pensado en eso y nos cubre con esa DB,además es muy fácil crear las conexiones.
Todo esto corresponde al módulo Workbox-BackgroundSync.

		VIDEO 205 BACKGROUNDSYNC - REALIZAR PETICIONES POST SIN CONEXION

Importante: todos estos módulos vienen ya preinstalados,sólo hay que activarlos.
NOTA:hay que ser muy meticuloso a la hora de usar el disco duro del cliente.No es buena idea meter toda una DB completa ni tampoco deberían estar los datos mucho tiempo.También debo recordar que es volátil,y que el usuario podría borrarlo ininitencionalmente

Bien,puedo ver en este ejemplo que la DB se usa como un plugin,y que requiere de la estrategia NetworkOnly,pues los post,delete,etc suelen ser muy dinámicos:

importScripts(...)
workbox.loadModule('workbox-background-sync);

const { BackgroundSyncPlugin } = workbox.backgroundSync;

const bgSyncPlugin = new BackgroundSyncPlugin('myQueueName',{
  maxRetentionTime: 24 * 60 // 24h es buena idea
});

registerRoute(
  new RegExp(...),
  new NetworkOnly({
    plugins:[bgSyncPlugin] }),
  'POST',<- pueden ser varias o hay que hacer otro controller??
);

En cuanto haga un Post sin conexion,ojo, se acumulará en la indexedDB el posteo y en cuanto haya conexion se realizara solo.Dado que no estamos usando sockets tengo que recargar el navegador una vez para verlo.Increible.

					VIDEO 206 TAREA - PUT Y DELETE

El PUT y DELETE van a ser algo más complicados por que usan un param dinámico.El truco está en usar la regexp apropiada para esa ocasion:
registerRoute(
  new RegExp("http://localhost:4000/api/events*"),
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  "PUT"
);

registerRoute(
  new RegExp("http://localhost:4000/api/events*"),
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  "DELETE"
);
NOTA:fijate que cuando use un ServiceWorker también se crea un Manifest(está arriba de Service Workers).El Manifest le dice a la aplicación varias cosas como el background-color o los iconos.

Puedo ir a public/manifest.json y ver qué es lo que está metiendo la app al Manifest,y obviamente añadirle cosas:

{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
Por ejemplo,le puedo cambiar el short_name y el name.Recuerda que es el manifest.json de la carpeta public

IMPORTANTE:cuando un browser detecte el service worker y el manifest veré una opción para instalar la app.Puedo instalarla y veré una app de escritorio(puedo desinstalarla despues)

Quedaría refactorizar un poco el código,ya que hemos repetido bastante,pero puedo observar lo fácil que fue implementar PWA en la aplicación de producción.

			VIDEO 207 OPTIMIZANDO NUESTRO SERVICE-WORKER.JS	

En realidad puedo mandar varias cosas al registerRoute.Puedo mandarle una callback como primer argumento,si regresa true pasará al segundo.En esta callback puedo acceder a los objetos request y url:

workbox.routing.registerRoute(
  ({request,url}) => {
    console.log(request,url)
    return false;
  },
  new workbox.strategies.CacheFirst()
);

Request {method: 'GET', url: 'https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css', headers: Headers, destination: 'style', referrer: 'http://localhost:3000/', …} 
URL {origin: 'https://stackpath.bootstrapcdn.com', protocol: 'https:', username: '', password: '', host: 'stackpath.bootstrapcdn.com', …}
Puedo ver que tengo visión sobre cualquier metadata prácticamente.

Sabiendo esto puedo resumir bastante el código:

const cacheNetworkFirst = [`/api/auth/renew`, `/api/events`];

const cacheCacheFirst = [
  "https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css",
  "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css",
];

workbox.routing.registerRoute(
  ({ request, url }) => {
    if cacheNetworkFirst.includes(url.pathname) return true;
    return false;
  },
  new NetworkFirst()
);

registerRoute(
  ({request, url}) => {
    if (cacheCacheFirst.includes(url.href)) {
      return true;
    } else {
      return false;
    }
  },
  new CacheFirst()
);

Ojo que para las CDNs es url.href(aunque también se puede hacer de otras formas).

				VIDEO 208 MOSTRAR MENSAJES DE ONLINE - OFFLINE

Para realizar esto vamos a usar el paquete 'react-detect-offline':
>npm i react-detect-offline

Hay dos estrategias para implementar esta libreria:

UNA:
import { Offline, Online } from "react-detect-offline";

const App = () => (
  <div>
    <Online>Only shown when you're online</Online>
    <Offline>Only shown offline (surprise!)</Offline>
  </div>
);

DOS:
<Detector
  render={({ online }) => (
    <div className={online ? "normal" : "warning"}>
      You are currently {online ? "online" : "offline"}
    </div>
  )}
/>

Al final pongo algo asi en la navbar:
   <Online>
        <span className="text-success">Online</span>
      </Online>
      <Offline>
        <span className="text-danger">Offline</span>
      </Offline>

Fijate como aunque fuera una sección introductoria me ha servido mucho para entender una PWA y workbox.

		SECCION 17 MAPAS-MARCADORES-POLYLINES  WITH MAPBOX

Esta es una sección bonus añadida después de haber terminado el curso, la cual tiene por objetivo aprender:

1- Uso de Mapbox con TypeScript
2- Rutas y direcciones
3- Marcadores
4- Comunicación entre contextos
5- Distancia entre dos puntos
6- Duración aproximada del viaje

Es una sección bien interesante que les puede servir mucho, especialmente si quieren realizar cualquier trabajo con mapas en sus aplicaciones móviles o web.

			VIDEO 212-213 INICIO - CREANDO EL CONTEXTO DE LUGARES

Creamos una nueva app en typescript,siguiendo las instrucciones de Fernando.Fijate que usaremos el ContextAPI por comodidad,y que Fernando sugiere usar tres archivos por cada Contexto que use:

* Uno para el createContext(PlacesContext.ts):

import { createContext } from "react";

export interface PlacesContextProps {
  isLoading: boolean
  userLocation?: [number, number] 
}

export const PlacesContext = createContext({} as PlacesContextProps);

* Otro para el Provider:
import { PlacesContext } from "./PlacesContext";

export interface PlacesState {
  isLoading: boolean;
  userLocation?: [number, number];

}

const INITIAL_STATE:PlacesState = {
  isLoading: true,
  userLocation: undefined
};

type  Children = {
  children: JSX.Element | JSX.Element[]
}
export const PlacesProvider = ({ children }:Children) => {

  return (
    <PlacesContext.Provider value={{ 
      isLoading: INITIAL_STATE.isLoading,
      userLocation: INITIAL_STATE.userLocation,
     }}>
      {children}
    </PlacesContext.Provider>
  );
};

* Otro para la función pura reductora(fijate que el createContext y éste no devuelven JSX):
import { PlacesState } from "./PlacesProvider";

type PlacesAction = {
  type: "setUserLocation",
  payload: [number, number]

}

export const placesReducer = (state: PlacesState, action: PlacesAction): PlacesState => {

  switch (action.type) {
    case "setUserLocation":
      return {
        ...state,
        isLoading: false,
        userLocation: action.payload
      }
    default:
      return state;
  }
}

Para usar la función hay que usar el hook useReducer:

export const PlacesProvider = ({ children }: Children) => {
  const [state, dispatch] = useReducer(placesReducer, INITIAL_STATE);

  return (
    <PlacesContext.Provider
      value={{
        ...state,
      }}
    >
Fijate que con esparcir el state fue suficiente.En este punto debo memorizar estos pasos ya que es un cascarón perfecto para implementar la ContextAPI.
Fijate también que queda algun paso adicional para el dispatch,cuando lo resuelva actualizar el gist.

			VIDEO 215 OBTENER LA GEOLOCALIZACIÓN DEL HOST DEL USUARIO


Lo primero es ir a las ChromeDevTools,clickar en los tres puntos,despues en More Tools y despues en sensors ,alli puedo meter una lngLat custom(anécdotico).

Para obtener la geolocalización usaremos la navigator API ya integrada en del browser :

export const getUserLocation = async (): Promise<[number, number]> => {
  return new Promise((resolve, reject) => {
    /* también tengo watch para geolocalizar en movimiento */
    navigator.geolocation.getCurrentPosition(
      ({ coords }) => {
        resolve([coords.latitude, coords.longitude]);
      },
      (err) => {
        alert('no se pudo obtener la geolocalización')
        reject("Error: " + err);
      })
  })
}
Primeramente creo una Promise que resuelva a lo que yo quiero y despues la llamo en un efecto,para que sea la primera accion que se dispare:

export const PlacesProvider = ({ children }: Children) => {
  const [state, dispatch] = useReducer(placesReducer, INITIAL_STATE);

  useEffect(() => {
    ( async () => {
      const lngLat = await getUserLocation();
      dispatch({
        type: "setUserLocation",
        payload: lngLat,
    })})();
},[]);

			VIDEO 216 MOSTRAR LA GEOLOCALIZACIÓN DEL USUARIO EN PANTALLA

Una vez obtenida con la navigator API,disparada la accion inmediatamente se cargue la app queremos mostrarla por la UI.
Fijate que es mejor snipet rafc o tsrafc que rafce.

export const MapView = () => {
  const { isLoading, userLocation } = useContext(PlacesContext);

  if (isLoading) {
    return <Loading />;
  }

  return <div>{userLocation?.join("")}</div>;
};
Recuerda que puedo ir a Components y en los providers cambiar ese isLoading.Hazlo

					 VIDEO 217 MOSTRAR MAPA DE MAPBOX

Vamos a usar mapbox por motivos obvios.Fijate que la generación de tokens que tienen es muy buena,pudiendo incluso restringir las URLS desde las que se envia el token,para que no lo usen más que en mi web.
Para ver como se instala voy a documentación.Alli ya me dicen que puedo usar una CDN o la libreria mapbox-gl de npm

Genero un token y me traigo las cdns o uso npm.Recuerda que hay que esperar al DOM para cerciorarme que el div donde voy a meter el mapa existe:

 const mapDiv = useRef<HTMLDivElement>(null);

  useLayoutEffect(() => {
    if (!isLoading) {
      new Map({
        container: mapDiv?.current!,
        style: 'mapbox://styles/mapbox/streets-v11',
        center: userLocation,
        zoom: 4,
      });
    }
  }, [isLoading,userLocation]);
  
  if (isLoading) {
    return <Loading />;
  }

  return (
    <div
      ref={mapDiv}
      style={{
        height: "100vh",
        width: "100vw",
        position: "fixed",
        top: 0,
        left: 0,
      }}
    >
    </div>
  ; 

				VIDEO 218 CREAR EL CONTEXTO PARA EL MAPA

Lo más importante es que mapbox ya me da el tipo Map para tipar una propiedad.Sabiendo esto,nuestro contexto podria lucir en un primer momento como esto:

import { Map } from "mapbox-gl";
import { createContext } from "react";

interface MapContextProps {
  isMapReady: boolean;
  map?: Map;
}

export const MapContext = createContext({} as MapContextProps);

En cuanto al Provider fijate como luce.De nuevo la clave es que map sea undefined en un principio y opcional y recuerda que los children son un JSX.Element o un JSX.Element[]:

export interface MapState {
  isMapReady: boolean;
  map?:Map;
}

const INITIAL_STATE: MapState = {
  isMapReady: false,
  map: undefined,
};

type Children = {
  children: JSX.Element | JSX.Element[];
};

export const MapProvider = ({ children }: Children) => {
  const [state, dispatch] = useReducer(mapReducer, INITIAL_STATE);

  return (
    <MapContext.Provider
      value={{
        ...state,
      }}
    >
      {children}
    </MapContext.Provider>
  )
};

Y en cuanto al reducer de nuevo no nos complicamos:

type MapAction = {
  type: "setMap",
  payload: Map

}

export const mapReducer = (state: MapState, action: MapAction): MapState => {

  switch (action.type) {
    case "setMap":
      return {
        ...state,
        map: action.payload
      }
    default:
      return state;
  }
}
Genial.Recuerda usar el index para exportaciones masivas.Y fijate como puedo exportar un import por default:
export {default as Comp1} from './Comp1.jsx';
export {default as Comp2} from './Comp2.jsx';
Amazing,ya puedo volver a mi tsrafce cual prehistoric

Por último,si no quiero tener que tipar el Children puedo usar React.FC(de functional component) asin:

const CustomComponent: React.FC = ({ children }) => {
  return (
    <div>{children}</div>
  )
}

			VIDEO 219 ESTABLECER EL MAPA EN EL CONTEXTO

Es importante entender que realmente puedo abastecer a mi contexto con lo que quiera,puedo crear cualquier función y proveeerla a la APP.Por ejemplo,puedo crear una función que llame al dispatch de una acción y abastecer esa función:

export const MapProvider = ({ children }: Children) => {
  const [state, dispatch] = useReducer(mapReducer,INITIAL_STATE);

  const setMap = (map:Map) => {
    dispatch({
      type: "setMap",
      payload: map,
    });
  }
  
  return (
    <MapContext.Provider
      value={{
       ...state,
        setMap,
      }}
    >

Fijate que yo normalmente envio el dispatch y ya dispararé la acción.Ahora donde quiera puedo llamar al setMap que disparará esa acción.La verdad es que son formas distintas de hacerlo,puede ser útil esta aproximación.

			VIDEO 220 MARCADORES,POPUPS Y BOTON DE UBICACION

Bien,ahora si,ya queda esclarecido porqué ha creado una función custom y la abastece,ya que no sólo va a establecer el mapa sino que sacaré un marcador:

 const setMap = (map:Map) => { 

    const myLocationPopup = new Popup()
    .setHTML(`
      <h4>Aquí estoy</h4>
      <p>En algún lugar del mundo</p>`);
    
    const newMarker = new Marker({
      color:"#61dafb",
      draggable: true,
    })
    .setLngLat(map.getCenter())
    .setPopup(myLocationPopup)
    .addTo(map);
    
    dispatch({
      type: "setMap",
      payload: map,
    });
  }
Fijate como esta vez Fernando ha mejorado en esta aplicación de mapas
NOTA: realmente hay bastantes temas en la libreria,vamos a usar uno más bonito que el normal,fijate que incluso puedo crear mis propios temas.

Bien,y por último,dado que tengo acceso al map y a la ubicación del usuario puedo crear un botón que devuelva al usuario a la posición actual.La clave es map.flyTo() y mandarle la userLocation.

const onClick = () => {
    if(!isMapReady) throw new Error("Map is not ready, please wait");
    if(!userLocation) throw new Error("No hay ubicación de usuario")
    
    if (isMapReady) {
      map?.flyTo({
        center: userLocation,
        zoom: 12,
      });
    }
  }

IMPORTANTE: puedo crear cualquier cosa realmente,sólo hay que tener la imaginación para ello,en este caso fijate como Fernando crea un componente que es el icono de React y lo pone en fixed abajo a la derecha,quedando espectacular.

const ReactLogo = () => {
  return <img src={reactLogo} alt="react-logo" style={{
    position: "fixed",
    bottom:"20px",
    right:"20px",
    width:"130px",
    zIndex:9,
  }}/>;
};
export default ReactLogo;
No debo minusvalorar a position:fixed.

				VIDEO 222 SEARCH BAR Y DEBOUNCE MANUAL

Vamos a crear una caja de búsqueda que nos permita introducir ciudades,etc...
